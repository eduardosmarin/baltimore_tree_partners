---
title: "Deliverable for Blue Water Baltimore"
author: "Eduardo Marin (with Dexter H Locke)"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    theme: readable
    code_folding: hide
    fig_width: 8
    fig_height: 7
    fig_caption: true
    toc: true
    toc_float: true
    self_contained: true
    number_sections: true
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---

# Blue Water Baltimore

## Introduction

**Blue Water Baltimore** is a dedicated organization committed to
**restoring** and **preserving** the quality of the Baltimore region's
waterways. By safeguarding these vital resources, they promote a
**healthier environment**, support the **local economy** through green
spaces, and contribute to the well-being of the **community**. Their
work spans a range of essential activities, including pollution
investigation, trash cleanups, and water monitoring. Additionally, they
operate a **biyearly tree giveaway program** each Spring and Fall, aimed
at enhancing our local community.

![](images/bwb_stillmeadow_giveaway.png)

The following presentation will highlight an entry-level analysis of the
past **ten years**, from 2013 to 2023, of their tree giveaway program.
The analysis will be broken down in five different categories, being the
following:

-   *Location and time*
-   *Species*
-   *Watershed*
-   *Distribution*
-   *Host location*
-   *Origin-destination*

> The data will highlight the distinctive and meaningful contributions
> from Blue Water Baltimore, especially in terms of environmental
> services, to our community

```{r Loading Packages, message=FALSE, include=FALSE}
# Loading all packages

# TODO load in 2019 acs

## List all of your packages here
knitr::opts_chunk$set(echo = TRUE)

packs <-c(
            'janitor'    # cleans things up, also pipe-friendly cross-tabulations
           , 'sf'         # for spatial data support
          , 'tidyverse'  # cuz
          # , 'tidylog'    # prints out what was done in dplyr and tidyr
          , 'magrittr'   # for the pipe
          , 'mapview'    # web maps for zooming and panning around
          #, 'beepr'      # makes noise when things are done!
          , 'tictoc'     # timing things.
          , 'raster'
          # , 'doParallel' # does what is says! PARALLEL
          # 'broom.mixed',# tidiers for mixed models AND nlme::gls()
          # , 'lubridate'   # DATES!
          , 'tidycensus' # tidy census package
          , 'tidygeocoder' # geo coding
          , 'leaflet' #creating the interactive mapping elements (more specific)
          , 'shiny'
          , 'leafsync'  # linked maps
          , 'RColorBrewer'
          , 'DT'
          , 'epitools'
          , 'openxlsx'
          , 'mapdeck'
          , 'biscale' #used with ggplot to make bivariate maps
          , 'cowplot' #used to make more aesthetic ggplot visuals
          , 'ggspatial' #creates a basemap for your ggplots
          , 'classInt' #find me breaks without doing manualcalculations
          , 'rgl' #needs for rayshader
          , 'rayshader' #good data viz for 3d bar graphs
          , 'leaflet' #for heatmaps and more unique, customizable maps
          , 'leaflet.extras'
          , 'tidytext'
          , 'shiny'
          , 'ggridges'
          , 'viridis'
          , 'ggpubr'
          , 'networkD3'
          )     

## IF the packages in 'packs' are not already installed, install them
## OTHERWISE do NOTHING
if (length(setdiff(packs, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packs, rownames(installed.packages())))
}

## lapply(packs, library, character.only = TRUE)
## this actually loads them with library(package_name)
vapply(packs, library, character.only = TRUE, logical(1), logical.return = TRUE, quietly = TRUE)

## For tidycensus
## Setting for get_acs
census_api_key('58fc555c77c229747ade7d9fe50e7c71297cf91a', install = TRUE, overwrite = TRUE)
readRenviron("~/.Renviron")
options(tigris_use_cache = TRUE)
```

```{r Loading Census Data, include=FALSE}
# Pulling census data
## Listing needed variables 

#TODO: Save this out the geopackage for this (1/1)
#FINISH: Save this out in the output_data folder, would have to return on chunks and you download it for it work

variables_acs <-
  tidycensus::load_variables('acs5', year = 2021)

my_vars <- c(  'median_household_income' = 'B19013_001'
             , 'total_population' = 'B01003_001'
             , 'households' = 'B11001_001'
             , 'white_alone' = 'B03002_003'
             , 'median_age' = 'B01002_001'
             , 'total_population_over_25' = 'B15003_001'
             , 'ed_hs_degree' = 'B15003_017'
             , 'ed_ged_degree' = 'B15003_018'
             , 'ed_college_less_1_year' = 'B15003_019'
             , 'ed_college_more_1_year' = 'B15003_020'
             , 'ed_associate_degree' = 'B15003_021'
             , 'ed_plus_bachelor_degree' = 'B15003_022'
             , 'ed_plus_master_degree' = 'B15003_023'
             , 'ed_plus_professional_degree' = 'B15003_024'
             , 'ed_plus_doctorate_degree' = 'B15003_025'
            )

# tidycensus::get_acs(
#       geography = 'state'
#     , state = 'MD'
#     , variables = my_vars
#     , year = 2021
#     , geometry = TRUE
#     , output = 'wide'
#     , moe_level = 95
#     ) |>
#   st_transform(crs = st_crs(4326)) |>
#   st_write("output_data/maryland.gpkg")
 
maryland <- 
  st_read("output_data/maryland.gpkg")

# tidycensus::get_acs(
#     geography = 'county'
#   , state = 'MD'
#   , variables = my_vars
#   , year = 2021
#   , geometry = TRUE
#   , output = 'wide'
#   , moe_level = 95
#   ) |>
#  st_transform(crs = st_crs(4326)) |>
#  st_write("output_data/maryland_counties.gpkg")

maryland_counties <-
  st_read("output_data/maryland_counties.gpkg")

# tidycensus::get_acs(
#     geography = 'county'
#   , state = 'MD'
#   , county = c('Baltimore City', 'Baltimore County')
#   , variables = my_vars
#   , year = 2021
#   , geometry = TRUE
#   , output = 'wide'
#   , moe_level = 95
#   ) |>
#  st_transform(crs = st_crs(4326)) |>
#  st_write("output_data/baltimore_city_counties.gpkg")

baltimore_city_counties <-
  st_read("output_data/baltimore_city_counties.gpkg")

 # tidycensus::get_acs(
 #      geography = 'county'
 #    , state = 'MD'
 #    , county = 'Baltimore City'
 #    , variables = my_vars
 #    , year = 2021
 #    , geometry = TRUE
 #    , output = 'wide'
 #    , moe_level = 95
 #    ) |>
 #   st_transform(crs = st_crs(4326)) |>
 #   st_write("output_data/city.gpkg")

city <-
  st_read("output_data/city.gpkg")

# tidycensus::get_acs(
#       geography = 'block group'
#     , state = 'MD'
#     # , county = 'all'
#     , variables = my_vars
#     , year = 2021
#     , geometry = TRUE
#     , output = 'wide'
#     , moe_level = 95
#     ) |>
#     st_transform(crs = st_crs(4326)) |>
#     mutate(county = case_when(
#       str_like(GEOID, '24510%') ~ "Baltimore City",
#       str_like(GEOID, '24005%') ~ "Baltimore County",
#       TRUE ~ "Neither"
#     )) |>
#     dplyr::select(-ends_with("M")) |> 
#     rename_with(~ gsub("E$", "", .x), ends_with("E")) |>  
#     rename(NAME = NAM) |>
#     mutate(
#       pct_at_least_hs = (100)*((rowSums(across(starts_with("ed_"))))/total_population_over_25), #This gets percentage
#       pct_at_least_college = (100)*((rowSums(across(starts_with("ed_plus"))))/total_population_over_25) #This gets percentage
#     )|> #TODO: divided by total, multipled by 100 (from the base 25+ population) to get a percentage (rename these here)
#     dplyr::select(-starts_with("ed_")) |>
#     st_write("output_data/cbg.gpkg")
  
cbg <-
  st_read("output_data/cbg.gpkg")

```

```{r Loading Geographies, message=FALSE, include=FALSE}
# Reading in the shapefile and creating mapview layers
## Making the Maryland layer
state_layer <-
 maryland |>
 mapview(alpha.regions = 0, lwd = 2, col.regions = "#525252", alpha = 0.25, layer.name = "Maryland") 

## Making the Baltimore County layer
jurisdiction_layer <-
  baltimore_city_counties |>
  mapview(alpha.regions = 0, lwd = 2, col.regions = "#525252", layer.name = "Baltimore City & jurisdiction") 

## Making the Baltimore city layer
city_layer <-
  city |>
  rename("Name" = "NAME") |>
  mutate("Name" = "Baltimore city") |>
  mapview(col.regions = "#525252", alpha = 0.25, layer.name = "Baltimore City")

#Making the Baltimore neighborhood read
neighborhood_read <-
  st_read("../baltimore_tree_partners_data_to_big/shapefiles/Neighborhood/Neighborhood.shp") |>
  dplyr::select(`Name`,`geometry`,`Shape__Are`,`Shape__Len`) |>
  st_zm(drop = TRUE, what = "ZM") |>
  st_transform(4326) |>
  mutate(`Area (Square Miles)` = as.numeric(st_area(geometry)) / 2.59e+6)

## Making the Baltimore neighborhood layer
neighborhood_layer <-
  neighborhood_read |>
  mapview(alpha.regions = 0, lwd = 2, col.regions = "#525252", zcol = "Name", layer.name = "Baltimore's Neighborhood")

## Weighted Neighborhood data
# weighted_neighborhood <- #TODO: DHL and Eduardo to figure out missing together, later.
#   interpolate_pw (
#     from = cbg                 
#   , to = neighborhood_read    
#   , to_id = "Name"         
#   , weights = cbg             
#   , weight_column = "total_population"
#   , weight_placement = "surface" 
#   , crs = 4326                 
#   , extensive = FALSE
#   )

# weighted_neighborhood |> 
#   st_write('output_data/weighted_neighborhood.gpkg')

## Reading in the Blue Water Giveaway data
blue_water_giveaway_data <-
   # st_read("../baltimore_tree_partners/output_data/blue_water_baltimore_data_2024-08-30.gpkg"
  # st_read("../baltimore_tree_partners/output_data/blue_water_baltimore_data_2024-12-27.gpkg"
  st_read('../baltimore_tree_partners_data_to_big/shapefiles/year_2013_to_2024_bwb_giveaway_2025-03-28.gpkg'
           , as_tibble = TRUE) %>%  #FINAL GEOPACKAGE!:) 
  # TODO add as_tibble everytime you do st_read
  filter(!st_is_empty(.))

## Making the Blue Water Giveaway layer
giveaway_layer <-
  blue_water_giveaway_data |>
  mapview(col.regions = "#5d6e75", alpha = 0.25, layer.name = "Total Tree Giveaways") 

## Reading in the Watershed Data
blue_water_watershed_data <-
 st_read("../baltimore_tree_partners_data_to_big/shapefiles/Maryland_Watersheds_-_8_Digit_Watersheds/HYDR_Watersheds8Digit_DNR.shp") |>
 st_transform(4326) 

## Creating filter for the Watershed Data
watershed_to_keep <-  #DEXTER: From your changes to 04_exploring
  c('02130901' # Black river
    , '02130903' # Baltimore Harbor
    , '02130905' # Gwynns Falls
    , '02130904' # Jones Falls
    )

## Making the Watershed Layer
watershed_data <-
  blue_water_watershed_data |>
  filter(mde8digt %in% watershed_to_keep) |>
  dplyr::select(mde6digt,mde6name,mde8digt,mde8name,geometry) |>
  rename(`Watershed ID (6)` = mde6digt, `watershed (6)` = mde6digt, `watershed` = mde8name, `watershed_id` = mde8digt) 

watershed_layer <-
  watershed_data |>
  mapview(col.regions = "#005273", alpha = 0.25, layer.name = "Watersheds")
```

```{r include=FALSE}
block_group_counts <-
  blue_water_giveaway_data |>
  dplyr::select(year, season, common_name, jurisdiction, giveaway_location, block_group_name, geoid) |>
  rename(NAME = block_group_name, GEOID = geoid) |>
  st_join(cbg[, c("NAME","GEOID")]) |>
  group_by(NAME.y, GEOID.y, year) |>
  summarise(count = n()) |>
  rename(NAME = NAME.y, GEOID = GEOID.y) |>
  st_drop_geometry()
  
census_count_map_layer <-
  cbg |>
  left_join(block_group_counts, by = c("NAME", "GEOID")) |>
  mutate(count = case_when(
    is.na(count) ~ 0,
    TRUE ~ count
  )) 

legend_order_census_count <- 
  classIntervals(
  census_count_map_layer$`count`,
  n = 8, # number of classes
  style = "fisher"
)$brks

census_count_map <-
  census_count_map_layer |>
  dplyr::select(-county) |>
  separate(NAME, into = c("Block Group","Census Tract","County","State"), sep = ", ") |>
  filter(County %in% c("Baltimore city","Baltimore County")) |>
  mapview(zcol = "count", layer.name = "Giveaway Count per Census Block", at = legend_order_census_count)
```

```{r Loading Tapestry, eval=FALSE, message=FALSE, include=FALSE}
# # 2019
# tap_path <- '/Users/dlocke/TAP/Tap2019/2019 Tapestry Complete.gdb/'
# st_layers(tap_path)
# 
# # a few test queries
# # tap_query <- 'SELECT * from TAP19_HH_bg limit 10'
# # tap_query <- 'SELECT * from TAP19_ADULT_bg limit 10' # NO
# # tap_query <- "SELECT ID, ST_ABBREV, TURBZNAME, TLIFENAME, TSEGNAME from TAP19_HH_bg WHERE ST_ABBREV = 'MD'"
# 
# tap_query <- "SELECT ID, ST_ABBREV, TURBZNAME, TURBZCODE, TLIFENAME, TLIFECODE, TSEGNAME, TSEGNUM from TAP19_HH_bg WHERE ST_ABBREV = 'MD'"
# 
# 
# tap <-
#   st_read(
#       tap_path
#     , query = tap_query
#     , as_tibble = TRUE
#   ) |>
#   rename(GEOID_2019 = ID) |>
#   # st_transform(st_crs(bwb_total_giveaway)) |>
#   st_transform(st_crs(blue_water_giveaway_data)) |> # is this right?
#   st_make_valid() |>
#   mutate(
#     urbanization =
#       factor(TURBZNAME
#              , levels = c(
#                  'Principal Urban Center'
#                , 'Urban Periphery'
#                , 'Metro Cities'
#                , 'Suburban Periphery'
#                , 'Semirural'
#                , 'Rural'
#                ))
#     , lifemode =
#       factor(TLIFENAME
#              , levels = c(
#                  'Affluent Estates'
#                , 'Upscale Avenues'
#                , 'Uptown Individuals'
#                , 'Family Landscapes'
#                , 'GenXurban'
#                , 'Cozy Country Living'
#                , 'Ethnic Enclaves'
#                , 'Middle Ground'
#                , 'Senior Styles'
#                , 'Rustic Outposts'
#                , 'Midtown Singles'
#                , 'Hometown'
#                , 'Next Wave'
#                , 'Scholars and Patriots')
#              )
#     , segment =
#       factor(TSEGNAME
#              , levels = c(
#                  'Top Tier'
#                , 'Professional Pride'
#                , 'Boomburbs'
#                , 'Savvy Suburbanites'
#                , 'Exurbanites'
#                , 'Urban Chic'
#                , 'Pleasantville'
#                , 'Pacific Heights'
#                , 'Enterprising Professionals'
#                , 'Laptops and Lattes'
#                , 'Metro Renters'
#                , 'Trendsetters'
#                , 'Soccer Moms'
#                , 'Home Improvement'
#                , 'Middleburg'
#                , 'Comfortable Empty Nesters'
#                , 'In Style'
#                , 'Parks and Rec'
#                , 'Rustbelt Traditions'
#                , 'Midlife Constants'
#                , 'Green Acres'
#                , 'Salt of the Earth'
#                , 'The Great Outdoors'
#                , 'Prairie Living'
#                , 'Rural Resort Dwellers'
#                , 'Heartland Communities'
#                , 'Up and Coming Families'
#                , 'Urban Villages'
#                , 'American Dreamers'
#                , 'Barrios Urbanos'
#                , 'Valley Growers'
#                , 'Southwestern Families'
#                , 'City Lights'
#                , 'Emerald City'
#                , 'Bright Young Professionals'
#                , 'Downtown Melting Pot'
#                , 'Front Porches'
#                , 'Old and Newcomers'
#                , 'Hardscrabble Road'
#                , 'Silver & Gold'
#                , 'Golden Years'
#                , 'The Elders'
#                , 'Senior Escapes'
#                , 'Retirement Communities'
#                , 'Social Security Set'
#                , 'Southern Satellites'
#                , 'Rooted Rural'
#                , 'Diners & Miners'
#                , 'Down the Road'
#                , 'Rural Bypasses'
#                , 'City Strivers'
#                , 'Young and Restless'
#                , 'Metro Fusion'
#                , 'Set to Impress'
#                , 'City Commons'
#                , 'Family Foundations'
#                , 'Traditional Living'
#                , 'Small Town Simplicity'
#                , 'Modest Income Homes'
#                , 'International Marketplace'
#                , 'Las Casas'
#                , 'NeWest Residents'
#                , 'Fresh Ambitions'
#                , 'High Rise Renters'
#                , 'Military Proximity'
#                , 'College Towns'
#                , 'Dorms to Diplomas'
#                , 'Unclassified'
#              ))
#   )
# 
# tap |>
#   st_drop_geometry() |>
#   write_csv(file = paste0('output_data/MD_Tapestry_2019_', Sys.Date(), '.csv'))
# 
# tap_lu <-
#   tap |>
#   st_drop_geometry() |>
#   distinct(urbanization, lifemode, segment)
# 
# save(tap_lu, file = paste0('output_data/tap_lu_', Sys.Date(), '.RData'))
# 
# # makes tap_lu a Look UP for the value
# # load('output_data/tap_lu_2024-06-25.RData')
# load('output_data/tap_lu_2024-04-03.RData')
# 
# 
# tap_lu |> map(~levels(.)) # order matters!
# 
# save(bwb_total_giveaway_with_Tapestry_2019, file = paste0('output_data/bwb_total_giveaway_with_Tapestry_2019_', Sys.Date(), '.RData'))
```

```{r Loading Tapestry Data, echo=FALSE, message=FALSE}
# makes 'bwb_total_giveaway_with_Tapestry_2019'
load('output_data/bwb_total_giveaway_with_Tapestry_2019_2024-06-25.RData')
```

<!-- # Color Palette -->

```{r Color Palette, eval=FALSE, include=FALSE}

## Branding (Shades of Blue)
   "#008CCC"
   "#005273"
   "#519342"
   
```

## Analysis

### Location and time

**Blue Water Baltimore** has operated its tree giveaway service for
[TODO: Insert Years]. In the past decade alone, they have distributed
approximately
**`r scales::comma(round(nrow(blue_water_giveaway_data)))`** trees
(`r nrow(blue_water_giveaway_data)` to be exact)." Although the figure
above is slightly overstated due to the inclusion of TreeBaltimore's
giveaway values in **2017** and **2018**, reflecting their partnership,
the impact of Blue Water Baltimore on our local waterways and the
environment is undeniable. Their tree giveaways have extended to
homeowners across Maryland, from **Frederick** to **Caroline**
**county**.

#### Heatmap of Tree Giveaway Plantings in Maryland

```{r echo=FALSE}
leaflet(blue_water_giveaway_data) |>
  addProviderTiles("CartoDB.Positron") |>
  addHeatmap(lng = ~st_coordinates(blue_water_giveaway_data)[,1], 
             lat = ~st_coordinates(blue_water_giveaway_data)[,2], 
             blur = 5, 
             max = 0.10, 
             radius = 6) |>
  addPolygons(data = maryland_counties, 
              color = "black",       
              weight = 2,            
              opacity = 1,           
              fillOpacity = 0)       
```

As shown on the map, there has been a high concentration of plantings in
**Baltimore County** and **Baltimore City** over the past ten years.
Plantings, although present, have been sparse in nearby counties, such
as **Howard**, **Anne Arundel**, **Carroll**, and **Harford**. This
distribution aligns with the general service area of Blue Water
Baltimore, which primarily covers the **Baltimore metropolitan region**.

Upon closer inspection of the map, there is a high concentration of
plantings in **Towson** and **Catonsville** within **Baltimore County**.
In **Baltimore City**, the trend shows plantings primarily in the
**northeastern** and **central** areas, including neighborhoods like
**Hamilton**, **Greater Govans**, **Waverly**, and **Hampden**.

To understand tree distribution giveaways, particularly at the
jurisdictional level, it's crucial to recognize how they change
throughout the year.

#### Line Graph of Tree Giveaways over the Years

```{r echo=FALSE}
jurisdiction_colors <-
  c("Baltimore City" = "#008CCC",
    "Baltimore County" = "#005273",
    "Neither" = "#519342")

graph_tree_plantings_over_years <-
  blue_water_giveaway_data |>
  st_drop_geometry() |>
  group_by(year, jurisdiction) |>
  summarise(`Number of Giveaways` = n(), .groups = 'drop') |>
  rename(Year = year, Jurisdiction = jurisdiction) |>
  mutate(Year = as.double(Year)) |>
  ggplot(aes(x = Year, y = `Number of Giveaways`, color = Jurisdiction)) +
   geom_line() +
   geom_point() +
    scale_x_continuous(
      breaks = seq(2013, 2023)
    ) +
     scale_y_continuous(
      limits = c(0, 1500),
      breaks = seq(0, 1500, by = 250),  
      labels = scales::comma  
    ) +
    scale_color_manual(values = jurisdiction_colors) +  
    labs(title = "Total Giveaways by Years for each Jurisdiction", 
         y = "Total Giveaways",
         color = "Jurisdiction") +  
    theme_minimal()

graph_tree_plantings_over_years
```

As shown, the growth in tree giveaways between Baltimore City and
Baltimore County has **varied significantly over the years**. It's
important to note that the data for **2018** and **2019** includes
contributions from **TreeBaltimore**, which may have influenced the
numbers. Additionally, when examining the seasons, the figures are
nearly identical.

If you look at the graph by **season**, however, different trends begin
to emerge, especially between **2021** and **2023**.

#### Line Graph of Tree Giveaways over the Years by Season

```{r echo=FALSE}
jurisdiction_colors = c(
   "Baltimore City" = "#008CCC",
   "Baltimore County" = "#005273",
   "Neither" = "#519342"
)

d_tree_plantings_over_years_seasons <-
  blue_water_giveaway_data |>
  st_drop_geometry() |>
  group_by(season, year, jurisdiction) |>
  summarise(`Number of Giveaways` = n(), .groups = 'drop') |>
  rename(Season = season, Year = year, Jurisdiction = jurisdiction) |>
  mutate(Year = as.double(Year))

graph_tree_plantings_over_years_seasons <-
  d_tree_plantings_over_years_seasons |>
  ggplot(aes(x = Year, y = `Number of Giveaways`, color = Jurisdiction)) +
   geom_line() +
   geom_point() +
    scale_x_continuous(
      breaks = seq(2013, 2023, by = 2)
    ) +
     scale_y_continuous(
      limits = c(0, 1000),
      breaks = seq(0, 1000, by = 250),  
      labels = scales::comma  
    ) +
    scale_color_manual(values = jurisdiction_colors) +  
    labs(title = "Total Giveaways by Years and Season for each Jurisdiction",
         x = "Year",
         y = "Total Giveaways",
         color = "Jurisdiction") +  
    theme_minimal() +
    facet_wrap(~ Season, scales = "free_y")

graph_tree_plantings_over_years_seasons
```

During the fall, the season follows the same general pattern as the
overall years, with a more significant increase in tree plantings in
Baltimore County compared to Baltimore City, especially in recent years.
Notably, in 2019, Baltimore County had a total of
`r d_tree_plantings_over_years_seasons |> filter(Year == 2019 & Season == "Fall" & Jurisdiction == "Baltimore County") |> pull("Number of Giveaways")`.

However, the story changes in the spring. Although Baltimore County has
generally had a higher number of tree plantings over the years, in 2023,
Baltimore City edged out Baltimore County with
`r d_tree_plantings_over_years_seasons |> filter(Year == 2023 & Season == "Spring" & Jurisdiction == "Baltimore City") |> pull("Number of Giveaways")`
compared to
`r d_tree_plantings_over_years_seasons |> filter(Year == 2023 & Season == "Spring" & Jurisdiction == "Baltimore County") |> pull("Number of Giveaways")`.

Highlighting the same information as before, the following table allows
you to search by year to find the largest entry and its exact amount.

#### Table of Tree Giveaways over the Year (per Jurisdiction)

```{r echo=FALSE, warning = FALSE}
 table_blue_water_baltimore_join <-
  blue_water_giveaway_data |>
  st_drop_geometry() |>
  group_by(jurisdiction, year) |>
  count() |>
  pivot_wider(names_from = year, values_from = n)
  
 blue_water_giveaway_data |>
  st_drop_geometry() |>
  tabyl(jurisdiction, year) |>
  as_tibble() |>
  filter(jurisdiction %in% c("Baltimore City", "Baltimore County", "Neither")) |>
 summarize(across(starts_with("20"), sum, na.rm = TRUE)) |>
 mutate(jurisdiction = "Total") |>
 bind_rows(table_blue_water_baltimore_join) |>
 dplyr::select(11, 1:10) |>
 arrange(match(jurisdiction, c(setdiff(unique(jurisdiction), "Total"), "Total"))) |>
 as_tibble() |>
 rename(Jurisdiction = jurisdiction) |>
 DT::datatable()
```

The following map visually presents this information, giving you the
opportunity to see the differences in tree giveaways between **seasons**
and **years**.

#### Map of Tree Giveaway Plantings in Maryland (Over Time):

```{r eval=FALSE, include=FALSE}
# Define the UI for the application
year_ui <- fluidPage(
  titlePanel("BWB Tree Giveaway Interactive Map with Year and Season Filter"),
  
  sidebarLayout(
    sidebarPanel(
      selectInput("year", "Select Year:", 
                  choices = sort(unique(blue_water_giveaway_data$year)), 
                  selected = sort(unique(blue_water_giveaway_data$year))[1]),  # Set default to the first year
      
      selectInput("season", "Select Season:", 
                  choices = sort(unique(blue_water_giveaway_data$season)), 
                  selected = sort(unique(blue_water_giveaway_data$season))[1])  # Set default to the first season
    ),
    
    mainPanel(
      leafletOutput("interactive_map"),
      verbatimTextOutput("debug_info")  # Text output for debugging info
    )
  )
)

# Server logic
server <- function(input, output, session) {
  
  # Reactive values to store input and filtered data for use in RMarkdown
  rv <- reactiveValues(selected_year = NULL, selected_season = NULL, filtered_data = NULL)
  
  # Reactive expression to filter data based on selected year and season
  observe({
    req(input$year, input$season)  # Ensure inputs are available
    rv$selected_year <- input$year
    rv$selected_season <- input$season
    
    rv$filtered_data <- blue_water_giveaway_data |> 
      filter(year == input$year, season == input$season)
  })
  
  # Render the Leaflet map
  output$interactive_map <- renderLeaflet({
    req(rv$filtered_data)  # Ensure data is available before rendering
    validate(need(nrow(rv$filtered_data) > 0, "No data available for selected filters."))
    
    leaflet(data = rv$filtered_data) |>
      addProviderTiles(providers$CartoDB.Positron) |>
      addCircleMarkers(
        radius = 2,
        fillOpacity = 0.1,
        color = "#2E6F40",
        popup = ~paste(
          "<b>Year:</b>", year, "<br>",
          "<b>Season:</b>", season, "<br>",
          "<b>Date:</b>", date, "<br>",
          "<b>Common Name:</b>", common_name, "<br>",
          "<b>Scientific Name:</b>", genus_species, "<br>",
          "<b>Address:</b>", address, "<br>",
          "<b>City:</b>", city, "<br>",
          "<b>State:</b>", state
        )
      )
  })
  
  # Render text output for debugging information
  output$debug_info <- renderText({
    paste(
      "Selected Year: ", rv$selected_year, "\n",
      "Selected Season: ", rv$selected_season, "\n",
      "Number of filtered rows: ", nrow(rv$filtered_data)
    )
  })
}

# Run the application
shinyApp(ui = year_ui, server = server)

#TO BE FAIR, DO NOT UNDERSTAND WAS DONE THRU CHATGPT & STACK (NEED TO LOOK INTO HOW IT WORKS BUT VERY COOL)

# `r blue_water_giveaway_data |> filter(Jurisdiction == "Baltimore City") |> summarise('Number of Giveaways') |> pull('Number of Giveaways)'` #TODO FIX
```

Given that Blue Water Baltimore's tree giveaways are primarily
concentrated within Baltimore City for most years, totaling [insert
number] giveaways over the past ten years. We will examine Baltimore
City more closely at the neighborhood level to better examine the
distribution of tree giveaways. Through this process, we will uncover if
there are any spatial patterns throughout the years and if distributions
have been changing significantly.

#### Map of Tree Plantings in Baltimore Neighborhoods

```{r echo=FALSE, message = FALSE}
figure_4_tree_neighborhoods_layer <-
neighborhood_read |>
  left_join(
    read_csv("../baltimore_tree_partners/output_data/neighborhood_count_bwb.csv")
    , by = "Name"
  ) |>
  mutate(count = case_when(
    is.na(count) ~ 0,
    TRUE ~ count),
    Density = (count/`Area (Square Miles)`)
  ) |>
  rename(`Number of Trees` = count) 

figure_4_tree_neighborhood_legend <- 
  classIntervals(
  figure_4_tree_neighborhoods_layer$`Number of Trees`,
  n = 10, 
  style = "fisher"
)$brks

figure_4_tree_neighborhoods_layer |>
  mapview(zcol = "Number of Trees", layer.name = "Number of Tree Giveaways", at = figure_4_tree_neighborhood_legend) 

```

As previously noted, a significant proportion of total tree plantings
has been concentrated in Northeast, Central, and Southeast Baltimore.
Specifically, the top ten neighborhoods with the highest number of tree
plantings are listed in descending order:
`r figure_4_tree_neighborhoods_layer |> arrange(desc('Number of Trees')) |> slice(1:9) |> pull(Name) |> paste(collapse = ", ")`,
followed by
`r figure_4_tree_neighborhoods_layer |> arrange(desc('Number of Trees')) |> slice(10) |> pull(Name)`.

#### Table of Plantings in Each Neighborhood

```{r eval=FALSE, message=FALSE, include=FALSE}
figure_4_tree_neighborhoods_layer <- 
  weighted_neighborhood |>
  st_drop_geometry() |>
  left_join(figure_4_tree_neighborhoods_layer, by = "Name") 

figure_4_tree_neighborhoods_layer |>
  mutate(`Trees per Household` = `Number of Trees`/households) |>
  mutate(`Trees per Household` = case_when(
    is.na(`Trees per Household`) ~ 0, #TODO: Dexter, can I do this and is this a fair assumption
    TRUE ~ `Trees per Household`
  )) |>
  arrange(desc(`Trees per Household`)) |>
  dplyr::select(Name, `Trees per Household`) |>
  DT::datatable()

```

Just as importantly, it

However, evaluating neighborhoods solely based on the giveaway count may
not provide a comprehensive view, as area sizes can vary significantly
among them.

may come surprising at first. However, these numbers are taking into
consideration the amount of space within each jurisdiction. They are
your number of trees in each neighborhood divided by the total square
miles of each neighborhood. The following highlights the absolute value
of tree plantings in each neighborhood.

Regardless, another interesting aspect to consider is how have the
absolute number of tree plantings have changed over the years. The
decision to not observe the density of tree plantings is since
neighborhood boundaries can change, alongside the amount of plantable
space over time.

#### Line Graph of Tree Plantings in Each Neighborhood (Top 5) Over the Years

```{r echo=FALSE, message = FALSE}
graph_3_filter_neighborhoods <-
  figure_4_tree_neighborhoods_layer |>
  dplyr::select(Name, `Number of Trees`) |>
  arrange(desc(`Number of Trees`)) |>
  slice(1:5)

graph_3_tree_plantings_year_neighborhood <-
  figure_4_tree_neighborhoods_layer |>
  st_drop_geometry() |>
  left_join(
    read_csv("../baltimore_tree_partners/output_data/neighborhood_count_year_bwb.csv"),
    by = "Name"
  ) |>
  rename(Year = year, Neighborhood = Name) |>
  dplyr::select(Neighborhood, `Number of Trees` = count, Year) |>
  dplyr::filter(Neighborhood %in% graph_3_filter_neighborhoods$Name) |>
  pivot_wider(names_from = Neighborhood, values_from = `Number of Trees`) |>
  add_row(Year = 2020) |>
  arrange(Year) |>
  pivot_longer(cols = c("Mount Washington","Hamilton","Lauraville","Westfield","Hampden"), 
               names_to = "Neighborhood", 
               values_to = "Number of Trees") |>
  replace_na(list(`Number of Trees` = 0)) |>
  mutate(Neighborhood = factor(Neighborhood, levels = graph_3_filter_neighborhoods$Name)) |>
  ggplot(aes(x = Year, y = `Number of Trees`, color = Neighborhood, group = Neighborhood)) +
  geom_line() +
  scale_x_continuous(breaks = seq(2013, 2023)) +
  labs(title = "Top 5 Neighborhoods and Number of Trees", x = "Year", y = "Number of Trees") +
  theme_minimal()

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "location_graph_tree_plantings_neighborhoods_top_5year.png"), 
  plot = graph_3_tree_plantings_year_neighborhood,
  width = 21,
  height = 10
)

graph_3_tree_plantings_year_neighborhood
```

#### Line Graph of Tree Plantings in Each Neighborhood (Top 5), Post COVID-19

```{r echo=FALSE, message = FALSE}
filter_post_covid <- 
  figure_4_tree_neighborhoods_layer |>
  st_drop_geometry() |>
  left_join(
    read_csv("../baltimore_tree_partners/output_data/neighborhood_count_year_bwb.csv"),
    by = "Name"
  ) |>
  filter(year > 2020) |>
  group_by(Name, year) |> 
  slice_max(order_by = count, n = 5, with_ties = FALSE) |>  
  ungroup() 


graph_3_tree_plantings_year_neighborhood <-
  figure_4_tree_neighborhoods_layer |>
  st_drop_geometry() |>
  left_join(
    read_csv("../baltimore_tree_partners/output_data/neighborhood_count_year_bwb.csv"),
    by = "Name"
  ) |>
  rename(Year = year, Neighborhood = Name) |>
  dplyr::select(Neighborhood, `Number of Trees` = count, Year)  |>
  view()

graph_3_tree_plantings_year_neighborhood <-
  figure_4_tree_neighborhoods_layer |>
  st_drop_geometry() |>
  left_join(
    read_csv("../baltimore_tree_partners/output_data/neighborhood_count_year_bwb.csv"),
    by = "Name"
  ) |>
  rename(Year = year, Neighborhood = Name) |>
  dplyr::select(Neighborhood, `Number of Trees` = count, Year) |>
  dplyr::filter(Neighborhood %in% graph_3_filter_neighborhoods$Name) |>
  pivot_wider(names_from = Neighborhood, values_from = `Number of Trees`) |>
  add_row(Year = 2020) |>
  arrange(Year) |>
  pivot_longer(cols = c("Mount Washington","Hamilton","Lauraville","Westfield","Hampden"), 
               names_to = "Neighborhood", 
               values_to = "Number of Trees") |>
  replace_na(list(`Number of Trees` = 0)) |>
  mutate(Neighborhood = factor(Neighborhood, levels = graph_3_filter_neighborhoods$Name)) |>
  ggplot(aes(x = Year, y = `Number of Trees`, color = Neighborhood, group = Neighborhood)) +
  geom_line() +
  scale_x_continuous(breaks = seq(2013, 2023)) +
  labs(title = "Top 5 Neighborhoods and Number of Trees", x = "Year", y = "Number of Trees") +
  theme_minimal()

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "location_graph_tree_plantings_neighborhoods_top_5year.png"), 
  plot = graph_3_tree_plantings_year_neighborhood,
  width = 21,
  height = 10
)

graph_3_tree_plantings_year_neighborhood

```

As you can see, the top ten neighborhoods, in descending order, are
`r paste(paste(graph_3_filter_neighborhoods$Name[1:9], collapse = ", "), ", and ", graph_3_filter_neighborhoods$Name[10], sep = "")`.
The most surprising feature is that these neighborhoods vary greatly in
terms of when their largest contribution were. Some, like Ednor
Gardens-Lakeside, had the most giveaways in 2013, while others had them
more recently like Hamilton Hills.

Nevertheless, as important as it is to understand when and where these
plantings have gone, it is also important to understand where they have
been received. occurred.

#### Graph of Tree Plantings in Maryland (per Year and Season)

```{r echo=FALSE}
season_colors <- c(
  "Fall" = "#008CCC",
  "Spring" = "#005273"
)

d_plantings_maryland_year_season <-
  blue_water_giveaway_data |>
  st_drop_geometry() |>
  group_by(season, year) |>
  summarise(`Number of Giveaways` = n(), .groups = 'drop') |>
  rename(Season = season, Year = year) |>
  mutate(Year = as.double(Year))

graph_plantings_maryland_year_season <-
  d_plantings_maryland_year_season |>
  ggplot(aes(x = Year, y = `Number of Giveaways`, fill = Season)) +
   geom_bar(position = "dodge", stat = "identity") +
    scale_fill_manual(values = season_colors) +
    scale_y_continuous(
      limits = c(0, 1750), 
      breaks = seq(0, 1500, by = 250),  
      labels = scales::comma  
    ) +
    scale_x_continuous (
      breaks = seq(2013, 2023) 
    ) +
    labs(title = "Total Giveaways by Year and Season",
         x = "Year",
         y = "Total Giveaways",
         fill = "Season") +
    theme_minimal() 

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "location_graph_1_tree_plantings_general_v1.png"), 
  plot = graph_plantings_maryland_year_season,
  width = 7,
  height = 7
) 


graph_plantings_maryland_year_season
```

Each year, there was a steady increase in number of giveaways until
**COVID-19,** after which the numbers have been gradually recovering to
reach **pre-pandemic levels.** Since the number of tree plantings within
the city reached

```{r eval=FALSE, include=FALSE}
##########################################################
# INTERNAL GRAPH 
##########################################################
graph_2_tree_plantings_year <-
  blue_water_giveaway_data |>
  st_drop_geometry() |>
  group_by(season, year, jurisdiction) |>
  summarise(`Number of Giveaways` = n(), .groups = 'drop') |>
  rename(Season = season, Year = year, jurisdiction = jurisdiction) |>
  mutate(Year = as.double(Year)) |>
  ggplot(aes(x = Year, y = `Number of Giveaways`, fill = Season)) +
   geom_bar(position = "stack", stat = "identity") +
    scale_fill_manual(values = season_colors) +
    scale_y_continuous(
      limits = c(0, 1500),          
      breaks = seq(0, 1500, by = 250),  
      labels = scales::comma  
    ) +
    scale_x_continuous (
      breaks = seq(2013, 2023, by = 2) 
    ) +
    labs(title = "Total Giveaways by Year and Season",
         x = "Year",
         y = "Total Giveaways",
         fill = "Season") +
    theme_minimal() +
    facet_wrap(~ jurisdiction)

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "location_graph_2_tree_plantings_jurisdiction.png"),
  plot = graph_2_tree_plantings_year, 
  width = 21, 
  height = 7
)

graph_2_tree_plantings_year
```

### Host Location

```{r include=FALSE}
unique_provider <-
 blue_water_giveaway_data |>
  st_drop_geometry() |>
  tabyl(giveaway_location) |> 
  as_tibble() |> 
  arrange(desc(n)) |>
  slice(-1) 

unique_provider_na <- 
 blue_water_giveaway_data |>
  st_drop_geometry() |>
  tabyl(giveaway_location) |> 
  as_tibble() |> 
  arrange(desc(n)) |>
  slice(1)  |>
  mutate(percent = 100*percent)

```

In terms of giveaway location, there are approximately
`r nrow(unique_provider)` different giveaway locations over the last ten
years. Each of them vary, especially in terms of amount.

#### Table of Giveaway Locations

```{r echo=FALSE}
  blue_water_giveaway_data |>
  st_drop_geometry() |>
  tabyl(giveaway_location) |> 
  rename(`Giveaway Location` = giveaway_location) |>
  as_tibble() |> 
  arrange(desc(n)) |>
  slice(-1) |> 
  rename("Number of Trees" = n, Percent = percent) |>
  mutate(Percent = round(100 * Percent, 2)) |>
  dplyr::select(-valid_percent) |>
  DT::datatable()
```

In the case of the amount of tree giveaway locations, the most stems
from Stillmeadow Community Fellowship. However, please understand that
the a large percentage are undefined, totaling
`r unique(unique_provider_na$n)`. This approximately accounts
for`r unique(unique_provider_na$percent)`% of the dataset.

#### Graph of Total Giveaway Locations

```{r echo=FALSE}
graph_4_giveaway_locations <-
  blue_water_giveaway_data |>
  st_drop_geometry() |>
  tabyl(giveaway_location) |>
  as_tibble() |> 
  arrange(desc(n)) |>
  slice(-1) |> 
  rename("Number of Trees" = n, `Giveaway Location` = giveaway_location) |>
  mutate(percent = round(100 * percent, 2)) |>
  ggplot(aes(x = reorder(`Giveaway Location`, `Number of Trees`), y = `Number of Trees`)) +
    geom_col(fill = "#519342") +
    coord_flip() +
    labs(title = "Giveaway Location and Number of Trees", x = "Giveaway Location", y = "Number of Trees") + #Dexter: How do I put percentages on the tips
    theme_minimal() +
    scale_y_continuous(expand = c(0, 0)) + 
    NULL

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "provider_graph_4_tree_plantings_neighborhoods_year.png"),
  plot = graph_4_giveaway_locations,
  width = 21,
  height = 10
)

#TODO: Dexter, confused and was trying to make it so that there was no odd space between this and the 0. Could not figure out how, though. 
    
graph_4_giveaway_locations
```

The next section will begin prying into information concerning species
from the tree giveaway. The goal will be to highlight new information
while still continuing answering previous questions, like where have
these species gone to spatially and what was the most sucessful species
given per each provider.

### Species

```{r include=FALSE}
colors_species <- c(
  "Serviceberry" = "#A52A2A",  
  "Sweetbay Magnolia" = "#8B4513",
  "Pawpaw" = "#D2691E",           
  "American Persimmon" = "#CD853F",
  "Common Fig" = "#DAA520",       
  "American Plum" = "#808000",    
  "American Holly" = "#6B8E23",   
  "Black Gum" = "#556B2F",        
  "Eastern Redbud" = "#4682B4",   
  "American Hornbeam" = "#8A2BE2" 
)

```

The following map highlights the top ten species giveaway in the
jurisdiction.

#### Map of Top 10 Species Giveaway

```{r echo=FALSE}
# Pulling top 10 species
species_order <- 
  blue_water_giveaway_data |>
  st_drop_geometry() |>
  count(common_name) |>
  arrange(desc(n)) |>
  slice(1:10) |>
  pull(common_name)


# Filtering, factoring, and mapping the data
blue_water_giveaway_data |>
mutate(common_name = case_when(
  common_name %in% species_order ~ common_name,
  TRUE ~ NA_character_
)) |>
filter(!is.na(common_name)) |>
mutate(common_name = factor(common_name, levels = species_order)) |>
dplyr::select(year, season, common_name, genus_species) |>
mapview(
zcol = "common_name",
col.regions = colors_species,
layer.name = "Top 10 Tree Species Planted from Blue Water Baltimore"
)

```

```{r echo=FALSE}
#Prepping for the next data frame
datatable_6_giveaway <-
blue_water_giveaway_data |>
  st_drop_geometry() |>
  tabyl(common_name) |>
  rename(`Common Name` = common_name) |>
  arrange(desc(n)) |>
  mutate(percent = round(100 * percent, 2))
  
datatable_6_giveaway_top_10 <-
  datatable_6_giveaway |>
  slice(1:10)
```

As you can see, there is a fair distribution of the highest
`r paste(datatable_6_giveaway_top_10$'Common Name'[1:9], collapse = ", ")`,
and `r datatable_6_giveaway_top_10$'Common Name'[10]`. As this is shown
in descending order, the most popular species for tree giveaways is
`r datatable_6_giveaway_top_10$'Common Name'[1]`. Investing more time
and energy into securing this species may be worthwhile for future tree
giveaways.

The following table will show you more in-depth the breakdown of the
different types of species given away.

```{r eval=FALSE, include=FALSE}
# Table 6. Table of the Species for the Giveaways
  datatable_6_giveaway |>
  rename(Count = n) |>
  DT::datatable()
```

In the case here, this visually displays the same information,
highlighting how distinct the most common and least common species are
in the amount of species give away.

#### Graph of the Most Common and Rare Tree Species

```{r echo=FALSE}
graph_5_common_rare_species <-
  datatable_6_giveaway |>
  rename(Count = n) |>
  mutate(group = rep(c("Common", "Rare"), each = 42)) |>
  ggplot(aes(Count, reorder(`Common Name`, Count))) + 
  geom_col(fill = "#519342") +
  theme_bw(base_size = 10) +
  labs(y = 'Common Name',
       x = 'Number of trees',
       title = 'Which tree species were most and least common?') +
  facet_wrap(~group, scales = 'free') +
  NULL

# ggsave(
#   filename = file.path("../baltimore_tree_partners/deliverables", "species_graph_5_common_rare_species.svg"), 
#   plot = graph_5_common_rare_species,
#   width = 22,
#   height = 10
# )

graph_5_common_rare_species
```

As mentioned earlier, an interesting aspect of this is to see and
understand how these relate to prior topics.

#### Table of Species by Jurisdictions

```{r}
table_7_species_jurisdictions <-
blue_water_giveaway_data |>
  st_drop_geometry() |>
  rename(`Common Name` = common_name) |>
  group_by(`Common Name`,`jurisdiction`) |>
  tabyl(`Common Name`,`jurisdiction`) |>
  mutate(`Total` = rowSums(across(c(`Baltimore City`,`Baltimore County`, `Neither`)))) |>
  arrange(desc(Total)) 
  
table_7_species_jurisdictions |>
DT::datatable()

table_7_species_jurisdictions_top_5_city <-
  table_7_species_jurisdictions |>
  arrange(desc(`Baltimore City`)) |>
  slice(1:5)

table_7_species_jurisdictions_top_5_jurisdiction <-
  table_7_species_jurisdictions |>
  arrange(desc(`Baltimore County`)) |>
  slice(1:5)
```

As you can see, for the most popular species, they tend to go more
heavily towards Baltimore City. However, another unique aspect is
finding out what the top five (5) of Baltimore City and Baltimore County
are. Of course, you can just rearrange the data table. If you do not
want to go through that process, however, here is the top five (5) for
Baltimore City:

`r paste(paste(table_7_species_jurisdictions_top_5_city$'Common Name'[1:4], collapse = ", "), ", and ",table_7_species_jurisdictions_top_5_city$'Common Name'[5], sep = "")`.

In the case of the the top five (5) for Baltimore County, they are the
following:
`r paste(paste(table_7_species_jurisdictions_top_5_jurisdiction$'Common Name'[1:4], collapse = ", "), ", and ",table_7_species_jurisdictions_top_5_jurisdiction$'Common Name'[5], sep = "")`.

Of course, these change respective of time. The next part will
underscore a graph of the top ten species within each jurisdiction:
Baltimore City, Baltimore County, and neither.

```{r include=FALSE}
# Graph 6. Graph of the Top Ten Species per each jurisdiction
graph_6_jurisdiction_top_species <-
blue_water_giveaway_data |>
  st_drop_geometry() |>
  rename(`Common Name` = common_name) |>
  group_by(jurisdiction, `Common Name`) |>
  summarize(Total = n(), .groups = 'drop') |>
  arrange(jurisdiction, desc(Total)) |>
  group_by(jurisdiction) |>
  slice_head(n = 10) |>
  group_by(jurisdiction) |>
  mutate(`Common Name` = fct_reorder(`Common Name`, Total, .desc = TRUE)) |>
  ggplot(aes(x = `Common Name`, y = Total)) +
  geom_bar(stat = "identity", fill = "#519342") +
  coord_flip() +
  facet_wrap(~ jurisdiction, scales = "free_y") +
  labs(title = "Top 10 Tree Species in Each jurisdiction",
       x = "Common Name",
       y = "Total Number of Trees") +
  theme_minimal() 

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "species_graph_6_top_ten_species_jurisdiction.png"), 
  plot = graph_6_jurisdiction_top_species,
  width = 33,
  height = 10
)

graph_6_jurisdiction_top_species 
```

Again, it is also important to understand what were the most popular
species given during each time of the year.

#### Graph of the Top Ten Species per year

```{r}
graph_7_year_top_species <-
blue_water_giveaway_data |>
  st_drop_geometry() |>
  rename(`Common Name` = common_name) |>
  group_by(year, `Common Name`) |>
  summarize(Total = n(), .groups = 'drop') |>
  arrange(year, desc(Total)) |>
  group_by(year) |>
  slice_head(n = 10) |>
  mutate(`Common Name` = fct_reorder(`Common Name`, Total, .desc = TRUE)) |>
  ggplot(aes(x = `Common Name`, y = Total)) +
  geom_bar(stat = "identity", fill = "#519342") + #Dexter: How do I fix the reordering to have it ascending/descending for both Baltimore County and Neither 
  coord_flip() +
  facet_wrap(~ year, scales = "free_y") +
  labs(title = "Top 10 Tree Species in Each Year",
       x = "Common Name",
       y = "Total Number of Trees") +
  theme_minimal() 

# ggsave(
#   filename = file.path("../baltimore_tree_partners/deliverables", "species_graph_7_top_ten_species_yearn.svg"), #TODO: Fix to make more general file saving path
#   plot = graph_7_year_top_species,
#   width = 20,
#   height = 15
# )

graph_7_year_top_species 
```

Finally, it is also important to understand if tree species differ based
off of giveaway location. If so, what are the most popular tree species
giveaway in the top five (5) giveaway location. The following graph,
like the others, will attempt to highlight this, specifically the top 10
species in each one.

#### Graph of the Top Ten Species per year

```{r}
top_five_giveaway_locations <-
  blue_water_giveaway_data |>
  st_drop_geometry() |>
  rename(`Common Name` = common_name) |>
  group_by(giveaway_location) |>
  summarize(Total = n(), .groups = 'drop') |>
  filter(!is.na(giveaway_location)) |>
  top_n(5, Total) |>
  pull(giveaway_location)

top_10_species_in_top_locations <-
  blue_water_giveaway_data |>
  st_drop_geometry() |>
  rename(`Common Name` = common_name) |>
  filter(giveaway_location %in% top_five_giveaway_locations) |>
  group_by(giveaway_location, `Common Name`) |>
  summarize(Total = n(), .groups = 'drop') |>
  group_by(giveaway_location) |>
  slice_head(n = 10) |>
  rename(`Giveaway Location` = giveaway_location) |>
  group_by(`Common Name`,`Giveaway Location`) |>
  summarize(Total = sum(Total), .groups = 'drop') |>
  arrange(desc(Total)) |>
  mutate(`Common Name` = fct_reorder(`Common Name`, Total, .desc = TRUE)) |>
  ggplot(aes(x = `Common Name`, y = Total)) +
  geom_bar(stat = "identity", fill = "#519342") +
  coord_flip() +
  facet_wrap(~ `Giveaway Location`, scales = "free_y") +
  labs(title = "Top 10 Tree Species in the Top 5 Giveaway Locations",
       x = "Common Name",
       y = "Total Number of Trees") +
  theme_minimal() #Dexter: How do I fix to make sure it is arranged in descending order

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "species_graph_top_10_species_in_top_locations.svg"), #TODO: Fix to make more general file saving path
  plot = top_10_species_in_top_locations,
  width = 40,
  height = 15
)

top_10_species_in_top_locations
```

TODO: Insert a blurb about the findings about but fix the descending
order

In addition to species, information on where these tree giveaways have
went relative to our watersheds is equally as important.

### Watersheds

To begin, here is a general map of the watersheds in the Baltimore
jurisdiction and Baltimore City region.

#### Map of Watersheds in BWB Service Area (In Respective to the

Counties)

```{r}
jurisdiction_layer + watershed_layer
#TODO: Add boundary, 
```

```{r}
#prepping for the statistic mentioned later
table_8_watershed_count <-
blue_water_giveaway_data |>
  st_drop_geometry() |>
  group_by(watershed) |>
  count() |>
  arrange(desc(n)) |>
  rename(Count = n) |>
  mutate(watershed = case_when(
    is.na(watershed) ~ "Outside BWB Service Area",
    TRUE ~ watershed
  ))
```

In terms of the plantings per watershed, these are the ones with the
most ones in descending order:
`r paste(paste(table_8_watershed_count$'watershed'[1:15], collapse = ", "), ", and ",table_8_watershed_count$'watershed'[16], sep = "")`.
A special thing to notice is that there is a total of
`r table_8_watershed_count |> filter('watershed' == "Outside BWB Service Area") |> pull(Count)`
outside of Blue Water Baltimore Service's area. The following will show
how this, relatively speaking, is a far lower margin that what we might
previously have imagined.

#### Table of Watersheds per Giveaway Count

```{r}
table_8_watershed_count_datatable <-
  blue_water_giveaway_data |>
  st_drop_geometry() |>
  tabyl(watershed) |>
  arrange(desc(n)) |>
  mutate(percent = round(100 * percent, 2)) |>
  rename(Count = n, Percent = percent) |>
  mutate(watershed = case_when(
    is.na(watershed) ~ "Outside BWB Service Area",
    TRUE ~ watershed
  )) |>
  rename(Watershed = watershed)

table_8_watershed_count_datatable |>
DT::datatable()
```

In terms of watersheds, it is important to see how many plants have gone
to these areas over time. The following graph will highlight this and
help distinguish if there is any statistical significance.

#### Number of Counts per Watershed per Year (per Season)

```{r}
graph_8_watersheds_count <-
  blue_water_giveaway_data |>
  mutate(watershed = case_when(
    is.na(watershed) ~ "Outside BWB Service Area",
    TRUE ~ watershed
  )) |>
  st_drop_geometry() |>
  rename(Watershed = watershed) |>
  group_by(year, Watershed, season) |>
  summarise(`Number of Giveaways` = n(), .groups = 'drop') |>
  rename(Year = year) |>
  mutate(Year = as.double(Year)) |>
  ggplot(aes(x = Year, y = `Number of Giveaways`, color = season, group = season)) +
  geom_line() + 
  geom_point() + 
  facet_wrap(~ `Watershed`, scales = "free_y") +
  scale_x_continuous(
    breaks = seq(2013, 2023, by = 2)
  ) +
  labs(title = "Total Giveaways by Year for Each Watershed",
       x = "Year",
       y = "Total Giveaways",
       color = "Season") +
  theme_minimal()
  
graph_8_watersheds_count 

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "graph_giveaways_watershed_seasons.png"), 
  plot = graph_8_watersheds_count,
  width = 40,
  height = 15
)

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "graph_giveaways_watershed_seasons.svg"), 
  plot = graph_8_watersheds_count,
  width = 40,
  height = 15
)
```

Here is a version of this but as a table.

```{r eval=FALSE, include=FALSE}
# Table 9. Table of Watersheds per Giveaway Count (per Season)
table_9_watersheds_count_year <-
  blue_water_giveaway_data |>
  mutate(watershed = case_when(
    is.na(watershed) ~ "Outside BWB Service Area",
    TRUE ~ watershed
  )) |>
  st_drop_geometry() |>
  rename(Watershed = watershed) |>
  group_by(year, Watershed, season) |>
  summarise(`Number of Giveaways` = n(), .groups = "drop") |>
  pivot_wider(names_from = c("year","season"), values_from = `Number of Giveaways`) |>
  rename_with(~ str_replace_all(., "_", ", "))

table_9_watersheds_count_year |>
  DT::datatable()
```

Besides understanding the breakdown of each watershed by season, it is
also important to understand the breakdown overall. In the following
graph, it will highlight the total amount of plantings in each watershed
per year.

#### Number of Giveaway Counts per Watershed (per Year)

```{r echo=FALSE, warning=FALSE}
graph_9_watersheds_count_year <-
  blue_water_giveaway_data |>
  mutate(watershed = case_when(
    is.na(watershed) ~ "Outside BWB Service Area",
    TRUE ~ watershed
  )) |>
  st_drop_geometry() |>
  rename(Watershed = watershed) |>
  group_by(season, year, Watershed) |>
  summarise(`Number of Giveaways` = n(), .groups = 'drop') |>
  rename(Year = year) |>
  mutate(Year = as.double(Year)) |>
  ggplot(aes(x = Year, y = `Number of Giveaways`)) +
  geom_col(fill = "#519342") + 
  scale_color_manual(values = season_colors) +
  facet_wrap(~ `Watershed`, scales = "free_y") +
  scale_x_continuous(
    breaks = seq(2013, 2023, by = 2)
  ) +
  labs(title = "Total Giveaways by Year for Each Watershed",
       x = "Year",
       y = "Total Giveaways") +
  theme_minimal()
  
graph_9_watersheds_count_year 

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "graph_giveaways_watershed_year.png"), 
  plot = graph_9_watersheds_count_year,
  width = 40,
  height = 15
)

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "graph_giveaways_watershed_year.svg"), 
  plot = graph_9_watersheds_count_year,
  width = 40,
  height = 15
)
```

#### Table of Watersheds per Giveaway Count (per Year)

```{r echo=FALSE, warning=FALSE}
table_10_watersheds_count_year <-
  blue_water_giveaway_data |>
  mutate(watershed = case_when(
    is.na(watershed) ~ "Outside BWB Service Area",
    TRUE ~ watershed
  )) |>
  st_drop_geometry() |>
  rename(Watershed = watershed) |>
  group_by(year, Watershed) |>
  summarise(`Number of Giveaways` = n(), .groups = "drop") |>
  arrange(Watershed, `year`) |>
  pivot_wider(names_from = "year", values_from = `Number of Giveaways`)

table_10_watersheds_count_year |>
   DT::datatable()
```

#### Five Popular Species per Watershed

```{r echo=FALSE}
graph_10_watersheds_species_count <-
  blue_water_giveaway_data |>
  mutate(watershed = case_when(
    is.na(watershed) ~ "Outside BWB Service Area",
    TRUE ~ watershed
  )) |>
  st_drop_geometry() |>
  rename(Watershed = watershed, `Common Name` = common_name) |>
  group_by(Watershed, `Common Name`) |>
  summarise(`Number of Giveaways` = n(), .groups = "drop") |>
  arrange(Watershed, desc(`Number of Giveaways`)) |>
  group_by(Watershed) |>
  slice_head(n = 5) |>
  ggplot(aes(x = `Number of Giveaways`, y = `Common Name`)) +
  geom_col(fill = "#519342") + 
  facet_wrap(~ `Watershed`, scales = "free_y") +
  labs(title = "Total Giveaways by Species",
       x = "Total Giveaways",
       y = "Top Five (5) Species" ) +
  theme_minimal()
  
graph_10_watersheds_species_count 

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "graph_giveaways_watershed_top_five.png"), 
  plot = graph_10_watersheds_species_count,
  width = 40,
  height = 15
)

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "graph_giveaways_watershed_top_five.svg"), 
  plot = graph_10_watersheds_species_count,
  width = 40,
  height = 15
)
```

### JEDI

We will first begin looking at income to see if there is any correlation
between that and the number of giveaways. In terms of the scale, we will
look specifically at the census block scale to determine this. We will
first look at a synced map

#### Income

TODO: Check how you are defining the giveaway counts if by household or
by area (should be household) TODO: Figure out how many trees are not in
block groups with NA \##### Synced Map of Household Income and Giveaway
Count (Per Census Blocks)

```{r echo=FALSE}
## Making the legend breaks
legend_order_census_income_count <- 
  seq(0, 200000, length.out = 9) 

## Making the census-income map
census_income_map <-
  cbg |>
  
  dplyr::select(-county) |>
  separate(NAME, into = c("Block Group","Census Tract","County","State"), sep = ", ") |>
  filter(County %in% c("Baltimore city","Baltimore County")) |>
  rename("Median Household Income" = median_household_income) |>
  # mutate(`Median Household Income` = case_when(
  #   is.na(`Median Household Income`) ~ 0, 
  #   TRUE ~ `Median Household Income`)) |>
  mapview(zcol = "Median Household Income", layer.name = "Household Income and Census Block", at = legend_order_census_income_count)

## The Sync Map of Count and Income
sync(census_income_map, census_count_map)
```

##### Regression Income Graph of Income and Count

```{r echo=FALSE, warning=FALSE}
regression_income_count_graph <-
  cbg |>
  left_join(
  read_csv("../baltimore_tree_partners/output_data/census_count_year.csv")
    , by = "NAME"
  )   |>
  ggplot(aes(x = median_household_income, y = count)) +
  geom_point(color =  "#008CCC") +
  geom_smooth(method = "lm", se = FALSE, color = "#519342") +
  labs(
    title = "Scatter Plot of Giveaway Counts Compared with Median Household Income",
    x = "Median Household Income",
    y = "Giveaway Count",
    subtitle = "Currently, 3k points not being captured due to NA giveaway location" 
  ) +
  scale_x_continuous(
    breaks = seq(0, 200000, by = 25000),
    labels = scales::dollar_format()
  ) +
  theme_minimal() +
  NULL

# Display the graph
regression_income_count_graph

```

##### Ridgeline Graph of Income over Year

```{r echo=FALSE, warning=FALSE}
gg_ridgeline_income_year_graph <-
blue_water_giveaway_data |> 
  st_drop_geometry() |> 
  mutate(year = factor(year, levels = c(2023:2013))) |> 
  ggplot(aes(x = median_household_income, y = year, fill = factor(..quantile..))) +
  stat_density_ridges(
    quantiles = c(0.2, 0.4, 0.6, 0.8),
    quantile_lines = TRUE,
    geom = "density_ridges_gradient",
    alpha = 0.6,
    scale = 2.3
  ) + 
  scale_fill_viridis(
    discrete = TRUE,
    name = "Quantile",
    alpha = 0.3,
    option = "mako"
  ) +
  theme_bw(base_size = 16) + 
  scale_x_continuous(
    labels = scales::dollar_format(),
    breaks = seq(0, 275000, by = 50000)
  ) + 
  theme(legend.position = "none") +
  labs(
    title = 'Density Graph of Giveaway Distribution and Median Household Income Over the Years',
    x = "Median Household Income",
    y = "Year"
  ) 

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "gg_ridgeline_income_year_graph.png"), 
  plot = gg_ridgeline_income_year_graph,
  width = 40,
  height = 15
)

gg_ridgeline_income_year_graph
```

##### Boxplot of the Income over Year

```{r echo=TRUE, warning=FALSE}
boxplot_income_years <-
  blue_water_giveaway_data |>
  st_drop_geometry() |>
  dplyr::select(median_household_income, year) |>
  ggpubr::ggboxplot(
    x = 'year', 
    y = 'median_household_income', 
    fill = 'year'
  ) +
  scale_fill_viridis_d(option = "mako", name = "Year") + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        legend.position = "none") +
  scale_y_continuous(
       limits = c(0, 275000),
      breaks = seq(0, 275000, by = 25000),  
      labels = scales::comma ) +
  labs(
    title = "Distribution of Household Income Across Different Years",
    x = "Year",
    y = "Median Household Income"
  ) + 
  NULL 

boxplot_income_years
```

##### Bivariate Map of Household Income and Giveaway Count (per

Census Block)

```{r echo=FALSE, warning=FALSE}
## CBG Bivariate
cbg_census_count <-
  cbg |>
  left_join(
  read_csv("../baltimore_tree_partners/output_data/census_count_year.csv")
    , by = "NAME"
  ) 

## setting the bivariate count and income
bivariate_count_income <-
  biscale::bi_class(cbg_census_count, x = median_household_income, y = count, style = "fisher", dim = 3)

## create the bivariate map
bivariate_count_income_map_pre <-
  bivariate_count_income |>
  separate(NAME, into = c("Block Group","Census Tract","County","State"), sep = ", ") |>
  filter(County %in% c("Baltimore city")) |>
  ggplot() +
  geom_sf(mapping = aes(fill = bi_class), color = "white", 
          size = 0.1, show.legend = FALSE) +
  bi_scale_fill(pal = "PurpleOr", dim = 3) +
  labs(
    title = "Household Income and Giveaway Count",
    subtitle = "ACS & BWB Data"
  ) +
  theme(
    plot.title = element_text(size = 10),     
    plot.subtitle = element_text(size = 5)    
  ) +
  bi_theme()

## create the bivariate map's legend
bivariate_count_income_map_legend <- 
  bi_legend(pal = "PurpleOr",
            dim = 3,
            xlab = "Higher Median Household Income",
            ylab = "Higher Giveaway Count",
            size = 3)

## making combined map
bivariate_count_income_map <- 
  ggdraw() +
  draw_plot(bivariate_count_income_map_pre, 0, 0, 1, 1) +
  draw_plot(bivariate_count_income_map_legend, .1, .1, 0.2, 0.2)

## calling map
bivariate_count_income_map

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "graph_bivariate_income_giveaway.svg"), 
  plot = bivariate_count_income_map,
  width = 45,
  height = 12
)

```

#### Education

##### Synced Map of High School Education and Giveaway Count (Per Census

Blocks)

```{r echo=FALSE, warning=FALSE}
## Making the legend breaks
legend_order_census_education_count <- 
  seq(0, 100, length.out = 9) 

## Makiing the census-education map
census_education_map <-
  cbg |>
  dplyr::select(-county) |>
  separate(NAME, into = c("Block Group","Census Tract","County","State"), sep = ", ") |>
  filter(County %in% c("Baltimore city","Baltimore County")) |>
  rename("Percentage At Least College" = pct_at_least_college) |>
  mapview(zcol = "Percentage At Least College", layer.name = "Percentage of At Least College Education and Census Block", at = legend_order_census_education_count)

## The Sync Map of Count and Income
sync(census_education_map , census_count_map)
```

##### Regression Education Graph and Count

```{r echo=FALSE, warning=FALSE}
regression_education_count_graph <-
  cbg |>
  left_join(
  read_csv("../baltimore_tree_partners/output_data/census_count_year.csv")
    , by = "NAME"
  )   |>
  ggplot(aes(x = pct_at_least_college, y = count)) +
  geom_point(color =  "#008CCC") +
  geom_smooth(method = "lm", se = FALSE, color = "#519342") + #DEXTER: Should this be a different form of regression. Heard about poison
  labs(
    title = "Scatter Plot of Giveaway Counts Compared with Individuals who have At Least College",
    x = "At Least College (Percentage)",
    y = "Giveaway Count"
  ) +
  scale_x_continuous(
    breaks = seq(0, 100, by = 10),
    labels = scales::comma 
  ) +
  theme_minimal() +
  NULL


# Display the graph
regression_education_count_graph

```

##### Ridgeline Graph of Education over Year

```{r echo=FALSE, warning=FALSE}
gg_ridgeline_education_year_graph <-
blue_water_giveaway_data |> 
  st_drop_geometry() |> 
  mutate(year = factor(year, levels = c(2023:2013))) |> 
  ggplot(aes(x = pct_at_least_college, y = year, fill = factor(..quantile..))) +
  stat_density_ridges(
    quantiles = c(0.2, 0.4, 0.6, 0.8),
    quantile_lines = TRUE,
    geom = "density_ridges_gradient",
    alpha = 0.6,
    scale = 2.3
  ) + 
  scale_fill_viridis(
    discrete = TRUE,
    name = "Quantile",
    alpha = 0.3,
    option = "mako"
  ) +
  theme_bw(base_size = 16) + 
  scale_x_continuous(
    labels = scales::comma,
    breaks = seq(0, 100, by = 10)
  ) + 
  theme(legend.position = "none") +
  labs(
    title = 'Density Graph of Giveaway Distribution and Education (At Least College)',
    x = "At Least College Degree (Percentage)",
    y = "Year"
  ) 

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "gg_ridgeline_education_year_graph.png"), 
  plot = gg_ridgeline_education_year_graph ,
  width = 40,
  height = 15
)

gg_ridgeline_education_year_graph 
```

##### Boxplot of the Education over Year

```{r echo=FALSE, warning=FALSE}
boxplot_education_years <-
  blue_water_giveaway_data |>
  st_drop_geometry() |>
  dplyr::select(pct_at_least_college, year) |>
  ggpubr::ggboxplot(
    x = 'year', 
    y = 'pct_at_least_college', 
    fill = 'year'  
  ) +
  scale_fill_viridis_d(option = "mako", name = "Year") + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        legend.position = "none") +
  scale_y_continuous(
       limits = c(0, 100),
      breaks = seq(0, 100, by = 10),  
      labels = scales::comma ) +
  labs(
    title = "Distribution of Education and Giveaway Counts aross Different Years",
    x = "Year",
    y = "At Least College Education (Percentage)"
  ) + 
  NULL

boxplot_education_years
```

##### Bivariate Map of Education and Giveaway Count (per

Census Block) ~ Baltimore City

```{r echo=FALSE, warning=FALSE}
## CBG Bivariate
cbg_census_count <-
  cbg |>
  left_join(
  read_csv("../baltimore_tree_partners/output_data/census_count_year.csv")
    , by = "NAME"
  ) 

## setting the bivariate count and income
bivariate_count_education <-
  biscale::bi_class(cbg_census_count, x = pct_at_least_college, y = count, style = "fisher", dim = 3)

## create the bivariate map
bivariate_count_education_map_pre <-
  bivariate_count_education |>
  separate(NAME, into = c("Block Group","Census Tract","County","State"), sep = ", ") |>
  filter(County %in% c("Baltimore city")) |>
  ggplot() +
  geom_sf(mapping = aes(fill = bi_class), color = "white", 
          size = 0.1, show.legend = FALSE) +
  bi_scale_fill(pal = "PurpleOr", dim = 3) +
  labs(
    title = "Education and Giveaway Count",
    subtitle = "ACS & BWB Data"
  ) +
  theme(
    plot.title = element_text(size = 10),     
    plot.subtitle = element_text(size = 5)    
  ) +
  bi_theme()

## create the bivariate map's legend
bivariate_count_education_map_legend <- 
  bi_legend(pal = "PurpleOr",
            dim = 3,
            xlab = "Higher Percentage of Adults with College Education",
            ylab = "Higher Giveaway Count",
            size = 3)

## making combined map
bivariate_count_education_map <- 
  ggdraw() +
  draw_plot(bivariate_count_education_map_pre, 0, 0, 1, 1) +
  draw_plot(bivariate_count_education_map_legend, .1, .1, 0.2, 0.2)

## calling map
bivariate_count_education_map

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "graph_bivariate_income_giveaway.svg"), 
  plot = bivariate_count_education_map,
  width = 45,
  height = 12
)
```

##### Bivariate Map of Education and Giveaway Count (per

Census Block) ~ Baltimore County

```{r echo=FALSE, warning=FALSE}
## CBG Bivariate
cbg_census_count <-
  cbg |>
  left_join(
  read_csv("../baltimore_tree_partners/output_data/census_count_year.csv")
    , by = "NAME"
  ) 

## setting the bivariate count and income
bivariate_count_education <-
  biscale::bi_class(cbg_census_count, x = pct_at_least_college, y = count, style = "fisher", dim = 3)

## create the bivariate map
bivariate_count_education_map_pre <-
  bivariate_count_education |>
  separate(NAME, into = c("Block Group","Census Tract","County","State"), sep = ", ") |>
  filter(County %in% c("Baltimore County")) |>
  ggplot() +
  geom_sf(mapping = aes(fill = bi_class), color = "white", 
          size = 0.1, show.legend = FALSE) +
  bi_scale_fill(pal = "PurpleOr", dim = 3) +
  labs(
    title = "Education and Giveaway Count",
    subtitle = "ACS & BWB Data"
  ) +
  theme(
    plot.title = element_text(size = 10),     
    plot.subtitle = element_text(size = 5)    
  ) +
  bi_theme()

## create the bivariate map's legend
bivariate_count_education_map_legend <- 
  bi_legend(pal = "PurpleOr",
            dim = 3,
            xlab = "Higher Percentage of Adults with College Education",
            ylab = "Higher Giveaway Count",
            size = 3)

## making combined map
bivariate_count_education_map <- 
  ggdraw() +
  draw_plot(bivariate_count_education_map_pre, 0, 0, 1, 1) +
  draw_plot(bivariate_count_education_map_legend, .1, .1, 0.2, 0.2)

## calling map
bivariate_count_education_map

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "graph_bivariate_education_giveaway.svg"), 
  plot = bivariate_count_education_map,
  width = 45,
  height = 12
)
```

#### Race

##### Synced Map of Race and Giveaway Count (Per Census

Blocks)

```{r echo=FALSE, warning=FALSE}
## Making the legend breaks
legend_order_census_race_count <- 
  seq(0, 100, length.out = 9) 

## Making the census-race map
census_race_map <-
  cbg |>
  mutate(pct_white_alone = 100*(white_alone/total_population)) |>
  dplyr::select(-county) |>
  separate(NAME, into = c("Block Group","Census Tract","County","State"), sep = ", ") |>
  filter(County %in% c("Baltimore city","Baltimore County")) |>
  rename("White (Percentage)" = pct_white_alone) |>
  mapview(zcol = "White (Percentage)", layer.name = "Percentage of White (Percentage) and Census Block", at = legend_order_census_race_count) #DEXTER: Will it be powerful to compare to black population instead Synced? unsure but seems interesting.

## The Sync Map of Count and Race
sync(census_race_map , census_count_map)
```

##### Regression Race Graph and Count

```{r echo=FALSE, warning=FALSE}
regression_race_count_graph <-
  cbg |>
  left_join(
  read_csv("../baltimore_tree_partners/output_data/census_count_year.csv")
    , by = "NAME"
  )   |>
  mutate(pct_white_alone = 100*(white_alone/total_population)) |>
  ggplot(aes(x = pct_white_alone, y = count)) +
  geom_point(color =  "#008CCC") +
  geom_smooth(method = "lm", se = FALSE, color = "#519342") + #DEXTER: Should this be a different form of regression. Heard about poison
  labs(
    title = "Scatter Plot of Giveaway Counts Compared with White (Percentage)",
    x = "White (Percentage)",
    y = "Giveaway Count"
  ) +
  scale_x_continuous(
    breaks = seq(0, 100, by = 10),
    labels = scales::comma 
  ) +
  theme_minimal() +
  NULL


# Display the graph
regression_race_count_graph
```

##### Ridgeline Graph of Race over Year

```{r echo=FALSE, warning=FALSE}
gg_ridgeline_race_year_graph <-
blue_water_giveaway_data |> 
  mutate(pct_white_alone = 100*(white_alone/total_population)) |>
  st_drop_geometry() |> 
  mutate(year = factor(year, levels = c(2023:2013))) |> 
  ggplot(aes(x = pct_white_alone, y = year, fill = factor(..quantile..))) +
  stat_density_ridges(
    quantiles = c(0.2, 0.4, 0.6, 0.8),
    quantile_lines = TRUE,
    geom = "density_ridges_gradient",
    alpha = 0.6,
    scale = 2.3
  ) + 
  scale_fill_viridis(
    discrete = TRUE,
    name = "Quantile",
    alpha = 0.3,
    option = "mako"
  ) +
  theme_bw(base_size = 16) + 
  scale_x_continuous(
    labels = scales::comma,
    breaks = seq(0, 100, by = 10)
  ) + 
  theme(legend.position = "none") +
  labs(
    title = 'Density Graph of Giveaway Distribution and White (Percentage)',
    x = "White (Percentage)",
    y = "Year"
  ) 

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "gg_ridgeline_race_year_graph.png"), 
  plot = gg_ridgeline_race_year_graph ,
  width = 40,
  height = 15
)

gg_ridgeline_race_year_graph 
```

##### Boxplot of the Race over Year

```{r echo=FALSE, warning=FALSE}
boxplot_race_years <-
  blue_water_giveaway_data |>
  mutate(pct_white_alone = 100*(white_alone/total_population)) |>
  st_drop_geometry() |>
  dplyr::select(pct_white_alone, year) |>
  ggpubr::ggboxplot(
    x = 'year', 
    y = 'pct_white_alone', 
    fill = 'year'  
  ) +
  scale_fill_viridis_d(option = "mako", name = "Year") + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        legend.position = "none") +
  scale_y_continuous(
       limits = c(0, 100),
      breaks = seq(0, 100, by = 10),  
      labels = scales::comma ) +
  labs(
    title = "Distribution of Race and Giveaway Counts aross Different Years",
    x = "Year",
    y = "White (Percentage)"
  ) + 
  NULL 

boxplot_race_years #DEXTER: 2018 and 2019 are very different. Did they do anything those years besides parterning with TreeBaltimore? Is there something to do with trust or along those lines?
```

##### Bivariate Map of Race and Giveaway Count (per

Census Block) ~ Baltimore City

```{r echo=FALSE, warning=FALSE}
## CBG Bivariate
cbg_census_count <-
  cbg |>
  left_join(
  read_csv("../baltimore_tree_partners/output_data/census_count_year.csv")
    , by = "NAME"
  ) |>
  mutate(pct_white_alone = 100*(white_alone/total_population))

## setting the bivariate count and race
bivariate_count_race <-
  biscale::bi_class(cbg_census_count, x = pct_white_alone, y = count, style = "fisher", dim = 3)

## create the bivariate map
bivariate_count_race_map_pre <-
  bivariate_count_race |>
  separate(NAME, into = c("Block Group","Census Tract","County","State"), sep = ", ") |>
  filter(County %in% c("Baltimore city")) |>
  ggplot() +
  geom_sf(mapping = aes(fill = bi_class), color = "white", 
          size = 0.1, show.legend = FALSE) +
  bi_scale_fill(pal = "PurpleOr", dim = 3) +
  labs(
    title = "Race and Giveaway Count",
    subtitle = "ACS & BWB Data"
  ) +
  theme(
    plot.title = element_text(size = 10),     
    plot.subtitle = element_text(size = 5)    
  ) +
  bi_theme()

## create the bivariate map's legend
bivariate_count_race_map_legend <- 
  bi_legend(pal = "PurpleOr",
            dim = 3,
            xlab = "Higher Percentage of White",
            ylab = "Higher Giveaway Count",
            size = 3)

## making combined map
bivariate_count_race_map <- 
  ggdraw() +
  draw_plot(bivariate_count_race_map_pre, 0, 0, 1, 1) +
  draw_plot(bivariate_count_race_map_legend, .1, .1, 0.2, 0.2)

## calling map
bivariate_count_race_map

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "graph_bivariate_race_giveaway.svg"), 
  plot = bivariate_count_race_map,
  width = 45,
  height = 12
)
```

##### Bivariate Map of Race and Giveaway Count (per

Census Block) - Baltimore County

```{r echo=FALSE, warning=FALSE}
## setting the bivariate count and race
bivariate_count_race <-
  biscale::bi_class(cbg_census_count, x = pct_white_alone, y = count, style = "fisher", dim = 3)

## create the bivariate map
bivariate_count_race_map_pre <-
  bivariate_count_race |>
  separate(NAME, into = c("Block Group","Census Tract","County","State"), sep = ", ") |>
  filter(County %in% c("Baltimore County")) |>
  ggplot() +
  geom_sf(mapping = aes(fill = bi_class), color = "white", 
          size = 0.1, show.legend = FALSE) +
  bi_scale_fill(pal = "PurpleOr", dim = 3) +
  labs(
    title = "Race and Giveaway Count",
    subtitle = "ACS & BWB Data"
  ) +
  theme(
    plot.title = element_text(size = 10),     
    plot.subtitle = element_text(size = 5)    
  ) +
  bi_theme()

## create the bivariate map's legend
bivariate_count_race_map_legend <- 
  bi_legend(pal = "PurpleOr",
            dim = 3,
            xlab = "Higher Percentage of White",
            ylab = "Higher Giveaway Count",
            size = 3)

## making combined map
bivariate_count_race_map <- 
  ggdraw() +
  draw_plot(bivariate_count_race_map_pre, 0, 0, 1, 1) +
  draw_plot(bivariate_count_race_map_legend, .1, .1, 0.2, 0.2)

## calling map
bivariate_count_race_map

ggsave(
  filename = file.path("../baltimore_tree_partners/deliverables", "graph_bivariate_race_giveaway.svg"), 
  plot = bivariate_count_race_map,
  width = 45,
  height = 12
)
```

### Tapestry

Levels
```{r warning=FALSE, include=FALSE}
tapestry_levels <- rev(
  c('Affluent Estates'
  , 'Upscale Avenues'
  , 'Uptown Individuals'
  , 'Family Landscapes'
  , 'GenXurban'
  , 'Cozy Country Living'
  , 'Ethnic Enclaves'
  , 'Middle Ground'
  , 'Senior Styles'
  , 'Rustic Outposts'
  , 'Midtown Singles'
  , 'Hometown'
  , 'Next Wave'
  , 'Scholars and Patriots'
))
```

Calculating the base rate
```{r include=FALSE}
#1. You first need the general ratio of the amount of trees per households
## a) Total households
city_cbg_2019 <-
  st_read("output_data/cbg_2019.gpkg") 

total_households_2019 <-
  city_cbg_2019$households |> #making a vector
  sum() #summing the vector for the total

## b) Total number of trees
total_tree_giveaways <-
  blue_water_giveaway_data |>
  st_drop_geometry() |>
  filter(year == 2019) |>
  filter(jurisdiction %in% c("Baltimore County","Baltimore City")) |>
  distinct(address) |> 
  count() |>
  pull(n) 

## c) Creating the base rate
base_rate_baltimore <-
  total_tree_giveaways / total_households_2019 #our null

```

Calculating the odds ratio
```{r include=FALSE}
#1. Need to create a combined shapefile to get the counts of households and plantings
## a) Finding total households within each tapestry group
join_tapestry_cbg <-
  read_csv("output_data/MD_Tapestry_2019_2024-09-16.csv") |> # TODO get level DHL tk
  mutate(GEOID = as.character(GEOID_2019))

#The purpose of this to get the number of households per lifemode
city_cbg_2019_tapestry <- 
  city_cbg_2019 |>
  left_join(join_tapestry_cbg, by = "GEOID") |>
  st_drop_geometry() |>
  group_by(lifemode) |> 
  summarize(household_count = sum(households.x, na.rm = TRUE)) |>
  filter(!is.na(lifemode)) 

## b) Finding total tree giveaways within each tapestry group
city_tree_counts_tapestry <-  
  bwb_total_giveaway_with_Tapestry_2019 |>
  st_drop_geometry() |>
  filter(year == 2019) |>
  filter(jurisdiction %in% c("Baltimore County", "Baltimore City")) |>
  distinct(address, .keep_all = TRUE) |> 
  group_by(lifemode) |>
  summarize(giveaway_count = n()) |>
  filter(!is.na(lifemode))

#Finding out the odds ratio and expected rates
df_odd_giveaway_tapestry_old <-
  city_cbg_2019_tapestry |>
  left_join(city_tree_counts_tapestry, by = "lifemode") |> 
  mutate(giveaway_count = ifelse(is.na(giveaway_count), 0, giveaway_count)) |>
  mutate(proportion_household = household_count/sum(household_count)) |>
  mutate(proportion_trees = giveaway_count/sum(giveaway_count),
         odds_ratio = proportion_trees/proportion_household) |>
  mutate(expected_rate = household_count*base_rate_baltimore) 

# Creating the confidence intervals
df_odd_giveaway_interval <-
  pois.exact(df_odd_giveaway_tapestry_old$giveaway_count, df_odd_giveaway_tapestry_old$expected_rate) #gives us the confidence interval. 

# Appending the confidence intervals
df_odd_giveaway_tapestry <- 
  df_odd_giveaway_tapestry_old |>
  bind_cols(
    lower_ci = df_odd_giveaway_interval$lower,
    upper_ci = df_odd_giveaway_interval$upper
  ) |>
  mutate(lifemode = factor(lifemode, levels = tapestry_levels))

```

Graph of the odds ratio
```{r echo=FALSE}
#2. Creating the graph like in the report
df_odd_giveaway_tapestry |>
  ggplot(aes(x = lifemode, y = odds_ratio)) +
  geom_point(color = "blue", size = 3) +                    
  geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci),      
                width = 0.2, color = "gray") +
  geom_hline(yintercept = 1, linetype = "dashed", color = "red") + #the odds base should be 1
  labs(title = "Odds Ratio of Tree Giveaways by Lifemode Group with 95% CI"
         , x = "Lifemode Group"
         , y = "Odds Ratio") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

###### Doing the same but for counties and cities 
```{r include=FALSE}
# Total households for each jurisdiction
total_households_city <- 
  city_cbg_2019 |>
  filter(county == "Baltimore City") |>
  pull(households) |>
  sum()

total_households_county <- 
  city_cbg_2019 |>
  filter(county == "Baltimore County") |>
  pull(households) |>
  sum()

# Total tree giveaways for each jurisdiction
total_tree_giveaways_city <- 
  blue_water_giveaway_data |>
  filter(year == 2019, jurisdiction == "Baltimore City") |>
  distinct(address) |>
  count() |>
  pull(n)

total_tree_giveaways_county <- 
  blue_water_giveaway_data |>
  filter(year == 2019, jurisdiction == "Baltimore County") |>
  distinct(address) |>
  count() |>
  pull(n)

# Base rates
base_rate_city <- 
  total_tree_giveaways_city / total_households_city

base_rate_county <- 
  total_tree_giveaways_county / total_households_county

# 2. Calculate household and tree counts for each lifemode, per jurisdiction
# Join tapestry data with city data to get household counts
join_tapestry_cbg <- 
  read_csv("output_data/MD_Tapestry_2019_2024-09-16.csv") |>
  mutate(GEOID = as.character(GEOID_2019))

# Household count by lifemode for each jurisdiction
city_cbg_2019_tapestry_city <- 
  city_cbg_2019 |>
  filter(county == "Baltimore City") |>
  left_join(join_tapestry_cbg, by = "GEOID") |>
  st_drop_geometry() |>
  group_by(lifemode) |>
  summarize(household_count = sum(households.x, na.rm = TRUE)) |>
  filter(!is.na(lifemode))

city_cbg_2019_tapestry_county <- 
  city_cbg_2019 |>
  filter(county == "Baltimore County") |>
  left_join(join_tapestry_cbg, by = "GEOID") |>
  st_drop_geometry() |>
  group_by(lifemode) |>
  summarize(household_count = sum(households.x, na.rm = TRUE)) |>
  filter(!is.na(lifemode))

# Tree giveaway count by lifemode for each jurisdiction
city_tree_counts_tapestry_city <- 
  bwb_total_giveaway_with_Tapestry_2019 |>
  filter(year == 2019, jurisdiction == "Baltimore City") |>
  distinct(address, .keep_all = TRUE) |>
  group_by(lifemode) |>
  summarize(giveaway_count = n()) |>
  filter(!is.na(lifemode))

city_tree_counts_tapestry_county <-  
  bwb_total_giveaway_with_Tapestry_2019 |>
  filter(year == 2019, jurisdiction == "Baltimore County") |>
  distinct(address, .keep_all = TRUE) |>
  group_by(lifemode) |>
  summarize(giveaway_count = n()) |>
  filter(!is.na(lifemode))

# 3. Calculate odds ratios and expected rates for each jurisdiction
# For Baltimore City
df_odd_giveaway_tapestry_city <- 
  city_cbg_2019_tapestry_city |>
  left_join(city_tree_counts_tapestry_city, by = "lifemode") |>
  mutate(
    giveaway_count = replace_na(giveaway_count, 0),
    proportion_household = household_count / sum(household_count),
    proportion_trees = giveaway_count / sum(giveaway_count),
    odds_ratio = proportion_trees / proportion_household,
    expected_rate = household_count * base_rate_city
  )

# For Baltimore County
df_odd_giveaway_tapestry_county <- 
  city_cbg_2019_tapestry_county |>
  left_join(city_tree_counts_tapestry_county, by = "lifemode") |>
  mutate(
    giveaway_count = replace_na(giveaway_count, 0),
    proportion_household = household_count / sum(household_count),
    proportion_trees = giveaway_count / sum(giveaway_count),
    odds_ratio = proportion_trees / proportion_household,
    expected_rate = household_count * base_rate_county
  )

# 4. Calculate confidence intervals for each jurisdiction
df_odd_giveaway_interval_city <- 
  pois.exact(df_odd_giveaway_tapestry_city$giveaway_count, df_odd_giveaway_tapestry_city$expected_rate)

df_odd_giveaway_interval_county <- 
  pois.exact(df_odd_giveaway_tapestry_county$giveaway_count, df_odd_giveaway_tapestry_county$expected_rate)

# 5. Append confidence intervals and set levels for each jurisdiction
df_odd_giveaway_tapestry_city <- 
  df_odd_giveaway_tapestry_city |>
      bind_cols(
        lower_ci = df_odd_giveaway_interval_city$lower,
        upper_ci = df_odd_giveaway_interval_city$upper
      ) |>
  mutate(lifemode = factor(lifemode, levels = tapestry_levels))

df_odd_giveaway_tapestry_county <- 
  df_odd_giveaway_tapestry_county |>
  bind_cols(
    lower_ci = df_odd_giveaway_interval_county$lower,
    upper_ci = df_odd_giveaway_interval_county$upper
  ) |>
  mutate(lifemode = factor(lifemode, levels = tapestry_levels))
```

```{r echo=FALSE}
# Plot for Baltimore City
df_odd_giveaway_tapestry_city |>
  ggplot(aes(x = lifemode, y = odds_ratio)) +
  geom_point(color = "blue", size = 3) +
  geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), 
                width = 0.2, color = "gray") +
  geom_hline(yintercept = 1, linetype = "dashed", color = "red") + 
  labs(title = "Odds Ratio of Tree Giveaways by Lifemode Group with 95% CI (Baltimore City)",
       x = "Lifemode Group",
       y = "Odds Ratio") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Plot for Baltimore County
df_odd_giveaway_tapestry_county |>
  ggplot(aes(x = lifemode, y = odds_ratio)) +
  geom_point(color = "blue", size = 3) +
  geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), 
                width = 0.2, color = "gray") +
  geom_hline(yintercept = 1, linetype = "dashed", color = "red") + 
  labs(title = "Odds Ratio of Tree Giveaways by Lifemode Group with 95% CI (Baltimore County)",
       x = "Lifemode Group",
       y = "Odds Ratio") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```



The map of Baltimore and tree giveaways
```{r echo=FALSE}
baltimore_giveaway_layer <-
bwb_total_giveaway_with_Tapestry_2019 |>
  st_zm(drop = TRUE, what = "ZM") |>
  st_transform(4326) |>
  mapview(zcol = "lifemode", layer.name = "Baltimore's Giveaways and Tapestry Group")

baltimore_giveaway_layer

#DEXTER
# - Would a heatmap be better?
# - Is there any other mappings to do for this?
```

#### Graph of Lifemode Group and Jurisdiction
```{r echo=FALSE}
lifemode_colors <- c(
    "Affluent Estates" = "#9e0142", 
    "Upscale Avenues" = "#d53e4f", 
    "Senior Styles" = "#f46d43", 
    "Middle Ground" = "#fdae61", 
    "Hometown" = "#e6f598", 
    "GenXurban" = "#abdda4", 
    "Uptown Individuals" = "#92b1e2", 
    "Scholars and Patriots" = "#3288bd", 
    "Midtown Singles" = "#5e4fa2", 
    "Family Landscapes" = "#E83F6F", 
    "Next Wave" = "#2274A5", 
    "Cozy Country Living" = "#FFBF00", 
    "Ethnic Enclaves" = "#32936F", 
    "Rustic Outposts" = "#9F9F92",
    "NA" = "#FFFFFF"
)

bwb_total_giveaway_with_Tapestry_2019 |>
  mutate(jurisdiction = ifelse(is.na(jurisdiction), "Neither", jurisdiction)) |>
  group_by(jurisdiction, lifemode) |>
  count() |>
  rename(`Number of Giveaways` = n) |>
  filter(!is.na(lifemode)) |>
  ggplot(aes(x = jurisdiction, y = `Number of Giveaways`, fill = lifemode)) +
  geom_bar(position = "dodge", stat = "identity") + 
  scale_fill_manual(values = lifemode_colors) +
  labs(title = "Lifemode Groups and Total Giveaway Number",
         x = "Count of Tree Giveaways",
         y = "Lifemode Groups") +
  theme_minimal()

```

#### Graph of Lifemode Group and Total Giveaway Number

```{r echo=FALSE}
#This is followed by the odds ratio. 

bwb_total_giveaway_with_Tapestry_2019 |>
  st_drop_geometry() |>
  group_by(lifemode) |>
  count() |>
  rename(Count = n) |>
  ggplot(aes(Count, lifemode, fill = lifemode)) +
  geom_col() +
  scale_fill_manual(values = lifemode_colors) +
  labs(title = "Lifemode Groups and Total Giveaway Number",
         x = "Count of Tree Giveaways",
         y = "Lifemode Groups") +
  theme_minimal()

#DEXTER
# - Like the other question. However, confused on what should be the goal here? Like,
#   what would be a rate out of?
```

#### Graph of Lifemode Group and Every Year
####
```{r echo=FALSE}
# Making a graph of the different lifegroups in Baltimore
lifeogroup_baltimore_years_facet <- 
  bwb_total_giveaway_with_Tapestry_2019 |> 
  st_drop_geometry() |> 
  add_row(year = "2020") |> 
  group_by(year, lifemode) |> 
  count() |> 
  rename(Count = n) |> 
  ggplot(aes(x = year, y = Count, color = lifemode, group = lifemode)) + 
  geom_line() + 
  geom_point() + 
  scale_color_manual(values = lifemode_colors) + 
  labs(
    title = "Lifemode Groups and Total Giveaway Number Line Graph",
    x = "Year",
    y = "Count of Tree Giveaways"
  ) + 
  theme_minimal()

lifeogroup_baltimore_years_facet

#Trying to do a graph that doesn't depend on magnitude
bwb_total_giveaway_with_Tapestry_2019 |> 
  st_drop_geometry() |> 
  add_row(year = "2020") |> 
  group_by(year, lifemode) |> 
  count() |> 
  rename(Count = n) |> 
  mutate(year = as.numeric(year)) |> 
  arrange(lifemode, year) |> 
  group_by(lifemode) |> 
  mutate(
    previous_count = lag(Count),
    percentage_increase = (Count - previous_count) / previous_count * 100  
  ) |> 
  ungroup() |>
ggplot(aes(x = year, y = percentage_increase, color = lifemode, group = lifemode)) + 
  geom_line() + 
  geom_point() + 
  scale_color_manual(values = lifemode_colors) + 
  scale_x_continuous(
    breaks = seq(2013, 2023, by = 2)
  ) +
  scale_y_continuous(
    breaks = seq(0, 1500, by = 250)
  ) +
  labs(
    title = "Year-over-Year Percentage Increase of Lifemode Groups' Tree Giveaways",
    x = "Year",
    y = "Percentage Increase (%)"
  ) + 
  theme_minimal()

#DEXTER
# - First, how do I make it so that a rate is shown? Would it be number of 
#   households a tree giveaway was given each year? How would I do this? I 
#   attempted that with the second graph but unsure if useful
#
# - Is it even a fair assumption to make, particularly since the tapestry is 
#   only of 2019. Is there other tapestry?
```

#### Graph of Lifemode Groups in Top 10 Giveaway Locations

```{r echo=FALSE}
# Making a graph of the different lifemode groups in the top ten location
#finding the top the top 10
giveaway_location_top_10 <-
  bwb_total_giveaway_with_Tapestry_2019 |>
  st_drop_geometry() |>
  filter(!is.na(giveaway_location)) |>
  group_by(giveaway_location) |>
  summarise(Total = n()) |>
  arrange(desc(Total)) |>
  slice(1:10) |>
  pull(giveaway_location) #gives you a vector instead the pull command

#filtering out and doing the rest
bwb_total_giveaway_with_Tapestry_2019 |>
  st_drop_geometry() |>
  filter(giveaway_location %in% giveaway_location_top_10) |>
  group_by(giveaway_location, lifemode) |>
  count() |>
  rename(Count = n) |>
  slice(1:10) |>
  ggplot(aes(Count, lifemode, fill = lifemode)) +
  geom_col() +
  scale_fill_manual(values = lifemode_colors) +
  labs(title = "Lifemode Groups and Total Giveaway Number Bar Graph",
         x = "Count of Tree Giveaways",
         y = "Lifemode Groups") +
  theme_minimal() +
  facet_wrap(~ giveaway_location)

#DEXTER 
# Like the other ones, just confused on how to make this the best. 
```

#### Graph of Top 5 Species for Each Lifemode Group

```{r echo=FALSE}
library(plotly)

# https://plotly.com/r/ #found this cool package and need to know when best to use it
  
plotly_graph <-
bwb_total_giveaway_with_Tapestry_2019 |>
  st_drop_geometry() |>
  group_by(lifemode, common_name) |>
  count() |>
  rename(Count = n) |>
  arrange(lifemode, desc(Count)) |>
  group_by(lifemode) |>
  slice_max(order_by = Count, n = 5, with_ties = FALSE) |>
  ungroup() |>
  ggplot(aes(x = Count, y = common_name, fill = common_name)) +
  geom_col() +
  labs(title = "Top 5 Species in Each Lifemode Group",
       x = "Count of Tree Giveaways",
       y = "Species") +
  theme_minimal() +
  facet_wrap(~ lifemode, scales = "free_y")  #Wanted to include a graph like this since I wanted to see if certain groups of individuals like certain plants. Turns out, not really. 

ggplotly(plotly_graph)

```


#### Box Plot of Tapestry Groups (Compared to Affluent Estates)

```{r echo=FALSE}
counts_per_cbg <- 
  bwb_total_giveaway_with_Tapestry_2019 |> 
  st_drop_geometry() |> 
  group_by(GEOID_2019) |> 
  count()

my_comp <- 
  list(
      c('Affluent Estates', 'Midtown Singles')
    ,  c('Affluent Estates', 'Upscale Avenues')
    , c('Affluent Estates', 'Senior Styles')
    , c('Affluent Estates', 'Middle Ground')
    , c('Affluent Estates', 'Hometown')
    , c('Affluent Estates', 'GenXurban')
    , c('Affluent Estates', 'Uptown Individuals')
    # , c('Affluent Estates', 'Scholars and Patriots')
    ) 


bwb_total_giveaway_with_Tapestry_2019 |> 
  st_drop_geometry() |> 
  distinct(lifemode, GEOID_2019) |> 
  left_join(counts_per_cbg, by = 'GEOID_2019') |> 
  filter(!is.na(lifemode)) |>
  ggpubr::ggboxplot(
    x = 'lifemode', 
    y = 'n', 
    fill = 'lifemode'
    # add = 'jitter'
  ) +
  ggpubr::stat_compare_means(label.y = 95, label.x = 12) + # Overall p-value
  ggpubr::stat_compare_means(comparisons = my_comp) + # Pairwise comparisons
  ylim(0, 200) +
  scale_fill_viridis_d(option = "mako", name = "Lifemode") + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        legend.position = "none") +
  labs(
    title = "Distribution of Counts Across Lifemodes",
    x = "Lifemode",
    y = "Giveaway Counts"
  ) + 
  NULL

# DEXTER: Not sure sure what 
# - Any other boxplots that I should do?
```


 


```
