---
title: "Exploratory Data Analysis of Blue Water Baltimore's Tree Giveaway data (2013 - 2023)"
author: "Eduardo Marin (with Dexter H Locke)"
date: "`r format(Sys.time())`"
output:
  html_document:
    theme: flatly
    code_folding: hide
    fig_width: 8
    fig_height: 7
    fig_caption: true
    toc: true
    toc_float: true
    self_contained: true
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---
#### The goal of the data was a preliminary step in providing more information and trying to learn more about the when, what, why, and who. The small RMarkdown report will include interactive tables, graphs, and figures highlighting giveaway information over the years. 

```{r message=FALSE, include=FALSE}

# List all of your packages here

knitr::opts_chunk$set(echo = TRUE)

packs <-c(
            'janitor'    # cleans things up, also pipe-friendly cross-tabulations
           , 'sf'         # for spatial data support
          , 'tidyverse'  # cuz
          # , 'tidylog'    # prints out what was done in dplyr and tidyr
          , 'magrittr'   # for the pipe
          , 'mapview'    # web maps for zooming and panning around
          #, 'beepr'      # makes noise when things are done!
          , 'tictoc'     # timing things.
          , 'raster'
          # , 'doParallel' # does what is says! PARALLEL
          # 'broom.mixed',# tidiers for mixed models AND nlme::gls()
          # , 'lubridate'   # DATES!
          , 'tidycensus' # tidy census package
          , 'tidygeocoder' # geo coding
          , 'leaflet' #creating the interactive mapping elements (more specific)
          , 'shiny'
          , 'leafsync'  # linked maps
          , 'RColorBrewer'
          , 'DT'
          , 'openxlsx'
          , 'mapdeck'
          )     

# IF the packages in 'packs' are not already installed, install them
# OTHERWISE do NOTHING
if (length(setdiff(packs, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packs, rownames(installed.packages())))
}

# lapply(packs, library, character.only = TRUE)
# this actually loads them with library(package_name)
vapply(packs, library, character.only = TRUE, logical(1), logical.return = TRUE, quietly = TRUE)


# # for tidycensus
# setting for get_acs
census_api_key('58fc555c77c229747ade7d9fe50e7c71297cf91a', install = TRUE, overwrite = TRUE)
readRenviron("~/.Renviron")
options(tigris_use_cache = TRUE)
```

```{r include=FALSE}
## B get census data
vars21 <- 
  tidycensus::load_variables('acs5', year = 2021)

my_vars <- c(  'pop'      = 'B01001_001'
             , 'medhhinc' = 'B19013_001'
             )

(MD <-
  tidycensus::get_acs(
      geography = 'state'
    , state = 'MD'
    , variables = my_vars
    , year = 2021
    , geometry = TRUE
    , output = 'wide'
    , moe_level = 95
    ) |>
   st_transform(crs = st_crs(4326)))

(cbg <-
  tidycensus::get_acs(
      geography = 'block group'
    , state = 'MD'
    , county = c('Baltimore City', 'Baltimore County')
    , variables = my_vars
    , year = 2021
    , geometry = TRUE
    , output = 'wide'
    , moe_level = 95
    ) |>
    st_transform(crs = st_crs(MD)) |>
    mutate(jurisdiction = case_when(
      str_like(GEOID, '24510%') ~ "Baltimore City",
      str_like(GEOID, '24005%') ~ "Baltimore County",
      TRUE ~ "Neither"
    )))
```

```{r message=FALSE, include=FALSE}
# Tree Tribble
species_data <- 
  tribble(
  ~common_name,        ~genus_species,            ~itree,
  "Hackberry",         "Celtis occidentalis",     "CEOC",
  "Willow Oak",        "Quercus phellos",         "QUPH",
  "Black Gum",         "Nyssa sylvatica",         "NYSY",
  "Eastern Redbud",    "Cercis canadensis",       "CECA",
  "Sassafras",         "Sassafras albidum",       "SAAL",
  "Chestnut Oak",      "Quercus prinus",          "QUPR",
  "Eastern Red Cedar", "Juniperus virginiana",    "JUVI",
  "Bald Cypress",      "Taxodium distichum",      "TADI",
  "Black Oak",         "Quercus velutina",        "QUVE",
  "American Holly",    "Ilex opaca",              "ILOP",
  "Sweetbay Magnolia", "Magnolia virginiana",     "MAVI",
  "American Sweetgum", "Liquidambar styraciflua", "LIST",
  "Bur Oak",           "Quercus macrocarpa",      "QUMA1",
  "Black Chokeberry",  "Aronia melanocarpa",      "ARME6",
  "Blackhaw Viburnum", "Viburnum prunifolium",    "VIPR",
  "Gingko",            "Ginkgo biloba",            "GIBI",
  "American Persimmon", "Diospyros virginiana",    "DIVI",
  "Flowering Cherry",   "Prunus yedoensis",        "PRYE",
  "Post Oak",           "Quercus stellata",        "QUST",
  "Chinkapin Oak",      "Quercus muehlenbergii",   "QUMU",
  "Tulip Poplar",       "Liriodendron tulipifera", "LITU",
  "Shortleaf Pine",     "Pinus echinata",          "PIEC",
  "Eastern White Pine", "Pinus americana",         "PIST",
  "Yellow Birch",       "Betula alleghaniensis",   "BEAL2",
  "American Yellowwood","Cladrastis luteau",       "CLLU",
  "Smooth Service Berry","Amelanchier laevis",     "AMLA",
  "Boxelder Maple",    "Acer negundo",             "ACNE",
  "American Linden",   "Tilia americana",          "TIAMRE",
  "American Plum",     "Prunus americana",         "PRAM"
  )
  
# Loading data
bwb_total_giveaway <-
  read_csv("output_data/bwb_giveaway_total_final_2024-05-13.csv") |>
  filter(!is.na(lat)) |> #Good double check
  st_as_sf(coords = c("long","lat"), crs = 4326) |> 
  st_join(cbg) |> 
  mutate(common_name = case_when(
    common_name == "Boxelder" ~ "Boxelder Maple",
    common_name == "Yoshino Flowering Cherry" ~ "Flowering Cherry",
    common_name == "Black Tupelo" ~ "Black Gum",
    common_name == "Chinquapin" ~ "Chinkapin Oak",
    common_name == "Breakfast" ~ "Other",
    common_name == "Blackhaw Vibernum" ~ "Blackhaw Viburnum",
    common_name == "Ginkgo" ~ "Gingko",
    TRUE ~ common_name
  )) |>
  filter(address != "822 Montpellier") |> 
  left_join(species_data, by = "common_name") |>
  mutate(
    genus_species = coalesce(genus_species.x, genus_species.y),
    itree = coalesce(itree.x, itree.y)
  ) |>
  dplyr::select(-genus_species.x, -genus_species.y, -itree.x, -itree.y) |>
  left_join(species_data, by = "genus_species") |>
  mutate(
    common_name = coalesce(common_name.x, common_name.y),
    itree = coalesce(itree.x, itree.y)
  ) |>
  dplyr::select(-common_name.x, -common_name.y, -itree.x, -itree.y, -county) |>
 mutate(genus_species = ifelse(common_name == "Other", "Other", genus_species),
       itree = ifelse(common_name == "Other", NA_character_, itree)) |>
  mutate(year = as.character(year)) |>
  mutate(giveaway_location = case_when(
    giveaway_location %in% c("Gwynns Falls/Leakin Park","Gwynns Falls Leakin Park", "GFLP") ~ "Gwynns Falls Leakin Park",
    TRUE ~ giveaway_location)) |>
  mutate(giveaway_location = case_when(
    giveaway_location == "Rogers Forge" ~ "Rodgers Forge",
    giveaway_location %in% c("West Towson","Westy Walk") ~ "West Towson ES",
    giveaway_location == "Gateway Park at Darley Park" ~ "Darley Park Gateway",
    giveaway_location == "Forestry Nursery" ~ "Herring Run Nursery",
    giveaway_location == "Greektown - John Ruhrah EMS" ~ "John Ruhrah ES",
    TRUE ~ giveaway_location
  ))

```

### A) When

#### Let us begin with the question of **when**. Here, we will highlight tree giveaways each year and how they compare by season.

#### **Map of Tree Giveaways Each Year**

```{r echo=FALSE}

# Define the customized color palette
colors_year <- c(
  "2013" = "#9e0142",
  "2014" = "#d53e4f", 
  "2015" = "#f46d43",
  "2016" = "#fdae61", 
  "2017" = "#fee08b",
  "2018" = "#e6f598", 
  "2019" = "#abdda4",
  "2021" = "#92b1e2",
  "2022" = "#3288bd", 
  "2023" = "#5e4fa2"
)

# Create a mapview object with customized colors
year_map <- 
  bwb_total_giveaway |>
  dplyr::select(giveaway_location, year, season, date, address, city, state, zip_code, geometry) |>
  mapview(zcol = "year", col.regions = colors_year, layer.name = "Tree Plantings each Year")

# Display the map
year_map
```

#### **Interactive Total Plantings Each Year Table**

```{r echo=FALSE}
# Creating the year data frame
bwb_giveaway_years <-
  bwb_total_giveaway |>
  st_drop_geometry() |>
  tabyl(year, season) |>
  as_tibble() |>
  mutate(Total = Fall + Spring) |>
  arrange(desc(Total))

# Creating the year data table
bwb_giveaway_years_dt <-
  bwb_giveaway_years |>
  DT::datatable()

# Calling the datatable
bwb_giveaway_years_dt
```

#### **Bar Chart of Total Plantings Each Year (Divided by Season)**

```{r echo=FALSE}
# Changing the data to be able to be a stacked column chart
bwb_giveaway_years_long <- 
  bwb_giveaway_years |>
  pivot_longer(cols = c(Fall, Spring), names_to = "season", values_to = "number_of_trees")

# Making the season colors
seasons_color <- c(
  "Fall" = "#fe6b40",
  "Spring" = "#6f9c3d"
)

# Creating the stacked column chart 
bwb_giveaway_years_long |>
  ggplot(aes(x = year, y = number_of_trees, fill = season)) +
    geom_bar(position = "stack", stat = "identity") +
    scale_fill_manual(values = seasons_color) +
    scale_y_continuous(
      limits = c(0, 2000),         
      breaks = seq(0, 2000, by = 250),  
      labels = scales::comma  
    )  +
    labs(title = "Total Giveaways by Year and Season",
         x = "Year",
         y = "Total Giveaways",
         fill = "Season") +
    theme_minimal() 
```

#### **Line Chart of Total Plantings Each Year (Divided by Season)**

```{r echo=FALSE}
# Creating the line graph
bwb_giveaway_years_long |>
  ggplot(aes(x = year, y = number_of_trees, color = season, group = season)) +
  geom_point() +
  geom_line() +
  scale_color_manual(values = seasons_color) +
  scale_y_continuous(
      limits = c(0, 2000),         
      breaks = seq(0, 2000, by = 250),  
      labels = scales::comma  
    ) +
  labs(
      title = "Number of Tree Giveaways by Year"
    , x = "Year"
    , y = "Total Giveaways"
  ) +
  theme_minimal() +
  NULL
```



### B) Where


#### The second question we must answer is **where**. Here, we will highlight the distribution of plantings. Many went to Baltimore City, Baltimore County, and outside the general area. We will also look at how these compare to plantings within Baltimore neighborhoods. Finally, we will look more closely at census tract information.


#### **Map of the Three Jurisdictions**

```{r include=FALSE}
# Reading in the state layer
state_read <-
  st_read("../baltimore_tree_partners_data_to_big/shapefiles/State_Boundaries/State_Boundaries.shp") |>
  st_zm(drop = TRUE, what = "ZM") |>
  st_transform(4326) |>
  dplyr::select(NAME, Shape__Are, Shape__Len, geometry)

# Making the state layer
state_layer <-
  state_read |>
  filter(NAME == "Maryland") |>
  mapview(col.regions = "#a3b18a", alpha = 0.25, layer.name = "Maryland") 

# Reading in the county layer
county_read <-
  st_read("../baltimore_tree_partners_data_to_big/shapefiles/County_Boundary/County_Boundary.shp") |>
  st_zm(drop = TRUE, what = "ZM") |>
  st_transform(4326)

# Making the county layer
county_layer <-
  county_read |>
  mapview(col.regions = "#588157", alpha = 0.25, layer.name = "Baltimore County") 

# Reading in the neighborhood layer
neighborhood_read <-
  st_read("../baltimore_tree_partners_data_to_big/shapefiles/Neighborhood/Neighborhood.shp") |>
  dplyr::select(`Name`,`geometry`,`Shape__Are`,`Shape__Len`) |>
  st_zm(drop = TRUE, what = "ZM") |>
  st_transform(4326)

# Making the neighborhood layer
neighborhood_layer <-
  neighborhood_read |>
  mapview(zcol = "Name", layer.name = "Baltimore's Neighborhood")

# Making the city layer
city_layer <-
  neighborhood_read |>
  summarize("Name") |> # Dissolve
  mutate(`"Name"` = "Baltimore City") |>
  rename(Name = `"Name"`) |>
  mapview(zcol = "Name", col.regions = "#344e41", alpha = .25, layer.name = "Baltimore City")
  
# Fixing the column information of the giveaway layer
neighborhood_intersect <-
  st_intersects(bwb_total_giveaway, neighborhood_read, sparse = FALSE) |>
  apply(1, any)

county_intersect <-
  st_intersects(bwb_total_giveaway, county_read, sparse = FALSE) |>
  apply(1, any)

bwb_total_giveaway <-
  bwb_total_giveaway |>
   mutate(county = case_when(
    neighborhood_intersect ~ "Baltimore City",
    county_intersect ~ "Baltimore County",
    TRUE ~ "Neither"
  ))

# Making the tree giveaway by county layer
county_colors <- c(
  "Baltimore City" = "#344e41",
  "Baltimore County" = "#588157", 
  "Neither" = "#a3b18a"
)
  
tree_giveaway_county_layer <- 
  bwb_total_giveaway |>
  dplyr::select(giveaway_location, year, season, date, address, city, state, zip_code, county, geometry) |>
  mapview(zcol = "county", col.regions = county_colors, layer.name = "Tree Giveaways and Location") 

# Making the general map of all three locations 
city_county_neither_map <-
  city_layer + county_layer + state_layer + tree_giveaway_county_layer
```

```{r echo=FALSE}
# Displaying the map
city_county_neither_map
```

#### **Interactive Plantings in Each Jurisdiction Table**

```{r echo=FALSE}
# Creating the jurisdiction data frame
bwb_giveaway_jurisdiction <-
  bwb_total_giveaway |>
  st_drop_geometry() |>
  tabyl(county) |>
  as_tibble() |>
  rename("Number of Trees" = n) |>
  arrange(desc("Number of Trees")) |>
  mutate(percent = round(100 * percent, 2))

# Creating the jurisdiction data table
bwb_giveaway_jurisdiction_dt <-
  bwb_giveaway_jurisdiction |>
  DT::datatable()

# Calling the datatable
bwb_giveaway_jurisdiction_dt
```

#### **Plantings in Each Jurisdiction in Each Year Data Table**

```{r echo=FALSE}
# Creating the jurisdiction and year frame
bwb_giveaway_jurisdiction_year <-
  bwb_total_giveaway |>
  st_drop_geometry() |>
  tabyl(county, year) |>
  as_tibble()
  
# Creating the jurisdiction data table
bwb_giveaway_jurisdiction_year_dt <-
  bwb_giveaway_jurisdiction_year |>
  DT::datatable()

# Calling the datatable
bwb_giveaway_jurisdiction_year_dt
```

#### **Plantings in Each Jurisdiction in Each Year Graph**

```{r echo=FALSE}
# Changing the data to be able to be a stacked column chart
bwb_jurisdiction_years_long <- 
  bwb_giveaway_jurisdiction_year |>
  pivot_longer(cols = -county, names_to = "Year", values_to = "number_of_trees")

# The colors of each county
county_colors <- c(
  "Baltimore City" = "#344e41",
  "Baltimore County" = "#588157", 
  "Neither" = "#a3b18a"
)

# Creating the stacked column chart 
bwb_jurisdiction_years_long |>
  mutate(Year = as.numeric(Year)) |> # HERE
  ggplot(aes(x = Year, y = number_of_trees, fill = county)) +
    geom_bar(position = "dodge", stat = "identity") +
    scale_fill_manual(values = county_colors) +
    scale_y_continuous(
      limits = c(0, 1500),         
      breaks = seq(0, 2000, by = 250),  
      labels = scales::comma  
    )  +
    labs(title = "Total Giveaways by Year and Jurisdiction",
         x = "Year & County",
         y = "Total Giveaways") +
    theme_minimal() +
    NULL
```

#### **Plantings in Each Jurisdiction (Separated Graph)**

```{r echo=FALSE}

## Comparing to county data
  bwb_total_giveaway |>
  st_drop_geometry() |>
  group_by(county, year, season) |>
  count() |>
  as_tibble() |>
  arrange(desc(n)) |>
  ggplot(aes(year, n, color = season, group = season)) +
  geom_point() +
  geom_line() +
  facet_wrap(~county) +
  theme_bw(16) +
  theme(axis.text.x = element_text(angle = 90, vjust = .5)) +
  NULL
  
```

#### **Planting Number in Each Neighborhood of Baltimore Map**

```{r include=FALSE}
# Finding the number of trees giveaway within each neighborhood (ORIGINAL)
  # bwb_total_giveaway |>
  # st_intersection(neighborhood_read) |>
  # st_drop_geometry() |> 
  # group_by(Name) |>
  # summarise(count = n()) |>
  # write_csv("output_data/neighborhood_count_bwb.csv")
```

```{r echo=FALSE}
# Making the neighborhood and count layer
legend_order_neighborhood_count <- 
  seq(0, 180, length.out = 10) 

neighborhood_count_layer <-
neighborhood_read |>
  left_join(
    read_csv("output_data/neighborhood_count_bwb.csv")
    , by = "Name"
  ) |>
  mapview(zcol = "count", layer.name = "Giveaway Count per Neighborhood", at = legend_order_neighborhood_count)
  
# Displaying the map
neighborhood_count_layer 
```

#### **Plantings in Each Neighborhood Data Table**

```{r echo=FALSE, message=FALSE}
# Creating the neighborhood data frame
bwb_giveaway_neighborhood <-
  neighborhood_read |>
  left_join(
    read_csv("output_data/neighborhood_count_bwb.csv")
    , by = "Name"
  ) |>
  st_drop_geometry() |>
  dplyr::select(-"Shape__Are", -"Shape__Len") |>
  rename("Number of Trees" = "count") |>
  arrange(desc(`Number of Trees`))

# Creating the neighborhood data table
bwb_giveaway_neighborhood_dt <-
  bwb_giveaway_neighborhood |>
  DT::datatable()

# Calling the datatable
bwb_giveaway_neighborhood_dt
```

#### **Top 20 Plantings of Neighborhood Graph**

```{r echo=FALSE}
# Getting the top 20 
neighborhood_giveaway_20 <-
  bwb_giveaway_neighborhood |> 
  arrange(desc(`Number of Trees`)) |>
  slice(1:20)

# Creating the top 20 graph
neighborhood_giveaway_20 |>  
ggplot(aes(x = reorder(Name, `Number of Trees`), y = `Number of Trees`)) +
  geom_col() +
  coord_flip() +
  labs(title = "Top 20 Neighborhood and Number of Trees", x = "Neighborhood", y = "Number of Trees") +
  theme_minimal()
```

#### **Plantings in Each Neighborhood and Year Data Table**

```{r eval=FALSE, include=FALSE}
# # Finding the number of trees giveaway within each neighborhood and year
#   st_intersection(bwb_total_giveaway, neighborhood_read) |>
#   st_drop_geometry() |> 
#   group_by(Name, year) |>
#   summarise(count = n()) |>
#   write_csv("output_data/neighborhood_count_year_bwb.csv")
```

```{r include=FALSE}
# Creating the neighborhood and year dataframe
bwb_giveaway_year_neighborhood <-
  neighborhood_read |>
  left_join(
    read_csv("output_data/neighborhood_count_year_bwb.csv")
    , by = "Name"
  ) |>
  st_drop_geometry() |>
  dplyr::select(-"Shape__Are", -"Shape__Len") |>
  rename("Number of Trees" = "count", "Year" = "year") |>
  arrange(desc("Number of Trees"))

# Creating the neighborhood data table
bwb_giveaway_year_neighborhood_dt <-
  bwb_giveaway_year_neighborhood |>
  pivot_wider(names_from = Year, values_from = `Number of Trees`) |>
  dplyr::select("Name","2013","2014","2015","2016","2017","2018","2019","2021","2022","2023") |>
  DT::datatable()
```

```{r echo=FALSE}
# Calling the datatable
bwb_giveaway_year_neighborhood_dt
```

#### **Giveaway Location Data Table**

```{r echo=FALSE}
# Creating the giveaway location data frame
bwb_giveaway_location <- 
  bwb_total_giveaway |>
  st_drop_geometry() |>
  tabyl(giveaway_location) |> 
  as_tibble() |> 
  arrange(desc(n)) |>
  slice(-1) |> # Removing the NA, will write an addendum saying "why"
  rename("Number of Trees" = n) |>
  mutate(percent = round(100 * percent, 2)) |>
  mutate(valid_percent = round(100 * valid_percent, 2))

# Number for subtitle
bwb_giveaway_location_na <- 
  bwb_total_giveaway |>
  st_drop_geometry() |>
  tabyl(giveaway_location) |> 
  as_tibble() |> 
  arrange(desc(n)) |>
  slice(1)

# Creating the giveaway location data table
bwb_giveaway_location_dt <-
  bwb_giveaway_location |>
  DT::datatable()

# Calling the datatable
bwb_giveaway_location_dt

```

#### **Giveaway Location Data Graph**

```{r echo=FALSE}
bwb_giveaway_location |>  
ggplot(aes(x = reorder(giveaway_location, `Number of Trees`), y = `Number of Trees`)) +
  geom_col() +
  coord_flip() +
  labs(title = "Giveaway Location and Number of Trees", x = "Giveaway Location", y = "Number of Trees",
  subtitle = gsub("\\. ", ".\n", paste0("Removed the largest group being NA. The total number of NA was ", bwb_giveaway_location_na$n, "." ))) +
  theme_minimal() +
  NULL
```

#### **Planting Number in Each Census Tract of Baltimore and Baltimore County Map**

```{r eval=FALSE, include=FALSE}
# # Finding the number of trees giveaway within each census block
#   st_intersection(bwb_total_giveaway, cbg) |>
#   st_drop_geometry() |> 
#   group_by(NAME) |>
#   summarise(count = n()) |>
#   write_csv("output_data/census_count_year.csv")
```

```{r include=FALSE}
# Making the neighborhood and count layer
legend_order_census_count <- 
  seq(0, 120, length.out = 7) 

census_count_map <-
  cbg |>
  left_join(
  read_csv("output_data/census_count_year.csv")
    , by = "NAME"
  ) |>
  mapview(zcol = "count", layer.name = "Giveaway Count per Census Block", at = legend_order_census_count)
  
# Displaying the map
```

```{r echo=FALSE}
census_count_map
```



### C) What

#### The third question we must answer is **what**. Here, briefly, we will look more specifically at the species giveaway in the area. 

#### **Top 10 Species Planted Map**
```{r echo=FALSE}
# Making the dataframe for the top 10 species map
top_10_species_read <-
  bwb_total_giveaway |>
  mutate(common_name = case_when(
    common_name %in% c("Serviceberry","Sweetbay Magnolia","Pawpaw","American Persimmon","Common Fig","American Plum","American Holly","Black Gum","Eastern Redbud", "American Hornbeam") ~ common_name, 
    TRUE ~ NA_character_
  )) |>
  filter(!is.na(common_name))

# Creating the colors for the species
colors_species <- c(
  "Serviceberry" = "#9e0142",
  "Sweetbay Magnolia" = "#d53e4f", 
  "Pawpaw" = "#f46d43",
  "American Persimmon" = "#fdae61", 
  "Common Fig" = "#fee08b",
  "American Plum" = "#e6f598", 
  "American Holly" = "#abdda4",
  "Black Gum" = "#92b1e2",
  "Eastern Redbud" = "#3288bd", 
  "American Hornbeam" = "#5e4fa2"
)

# Making the Top 10 Species Map (Struggling to make the legend follow the order above)
top_10_species_map <- 
  top_10_species_read |>
  dplyr::select(year, season, common_name, genus_species, geometry) |>
  mapview(zcol = "common_name", col.regions = colors_species, layer.name = "Top 10 Tree Species Planted from Blue Water Baltimore")

# Reading in the map
top_10_species_map
```

#### **Common Name Datatable**

```{r echo=FALSE}
# Making the species dataframe
bwb_common_read <-
  bwb_total_giveaway |>
  st_drop_geometry() |>
  tabyl(common_name) |>
  arrange(desc(n)) 

# Making the species datatable
bwb_common_read_dt <-
  bwb_common_read |>
  DT::datatable()

# Calling the datatable
bwb_common_read_dt

# Top 10 common name species
```

#### **Common Name Graph (Both Rare and Common)**

```{r echo=FALSE}
# Creating the groups for the graph
bwb_counts_common_name <-
  bwb_common_read |>
  mutate(group = rep(c("common", "rare"), each = 42))

# Making the double graph
bwb_counts_common_name |> 
  ggplot(aes(n, reorder(common_name, n))) + # pushes the bars in the desc order
  geom_col() +
  theme_bw(10) +
  labs(y = 'Common Name'
       , x = 'Number of trees'
       , title = 'Which tree species were most and least common?'
       , subtitle = paste0('lots of Serviceberry... they make up '
                           , round(bwb_counts_common_name|> slice(1) |> pull(percent) * 100, 2)
                           , ' percent of all giveaways')
       ) +
  facet_wrap(~group, scales = 'free') +
  NULL

```

### D) Who

#### The final question we must answer is **who**. Here, we will look more specifically at income and giveawaycount.

#### **Synced map of Household Income and Giveaway Count**

```{r echo=FALSE}
# Creating the income read.
census_income_read <- 
  cbg |>
  rename("Median Household Income" = medhhincE)

# Creating the census income map

legend_order_census_income_count <- 
  seq(0, 200000, length.out = 9) 

census_income_map <-
  census_income_read |>
  mapview(zcol = "Median Household Income", layer.name = "Household Income and Census Block", at = legend_order_census_income_count)

#Creating a Sync map of Giveaway Count and Census Block
sync(census_income_map, census_count_map)

```

#### **Scatter Plot of Household Income and Giveaway Count**
```{r include=FALSE}
# Preparing scatter plot dataframe
census_count_dataframe <-
  cbg |>
  left_join(
  read_csv("output_data/census_count_year.csv")
    , by = "NAME"
  ) |>
  rename("Median Household Income" = "medhhincE")

#Using ggplot for the scatter plot
scatter_plot_census <-
ggplot(census_count_dataframe, aes(x = count, y = `Median Household Income`)) +
  geom_point(color = "#abdda4") +
  labs(
    title = "Scatter Plot of Count vs. Median Household Income",
    x = "Count",
    y = "Median Household Income"
  ) +
  theme_minimal()
```


```{r echo=FALSE}
#Calling it
scatter_plot_census
```

# Notes of BWB May 24th Meeting:
 - Fix the common names
 - Fix the 2017 and 2018 year data
 - Fix the 2020 to make 
 - Normalization of the neighborhoods through square miles
 - Showing giveaways of the maps
 - Dexter is intereseted if the giveaways are going near their location
 - Preordering and phone calls, etc.
 - Species list needs reconciliations
 - Looked at the watersheds information
 - Are neighborhood trees going to more POC communities or white communities?
 - Running a climate susceiptibility for them to potentially change their species list
 - Finding applicabilities between other groups. See TreeBaltimore giveaways. Do the Grow Workshops track people closeby?
 - Reach people in lower outcome communities and we might have to deliver the trees (place more effort into that)
 - Chicago study showed and highlighted that within the neighborhood (people wanted more help in this end)
 - Look at Nathan Fran, the GIS person in Baltimore County. They do it erraditcally, Kary Obersten.
 - The main is something you can embed in the website within the About section. An interactive map where the public can click around. Something for the public to see. Maybe some JPEGs to place in some Power Points, as well
 - People can query by watershed, as well (so they can play with it)
- Figuring out how many actually get planted and how many actually survived. 

BWB notes

Sean self-taught GIS

2020 on bar and line charts should be zero, not NA

Cumulative? Giveaways

2018 and 2019 need to double check.

NA to zero on the giveaways maps

Plantings need some kind of normalization
	opportunities to plant

Top neighbor plantings
	high plantabilitiy
	high income

Switch to pre-ordering in the last two years
	total 5 tree per household limits
	no more than 3 understory trees per household

	pre-order between 10-12 (30% donâ€™t show up)
	add trees for walk ups

Phone call reminders
	October
	start planning September

Giveaway locations on the map
	origin to destination
	need locations of giveaways
	change the giveaway label

Right tree right place

Species lists need further reconciliation (with Sean)

Climate suceptability

=== HERE

Questions:

WATERSHED
	Darin to send shape file

Origin / destination
	https://stackoverflow.com/questions/44283774/flow-maptravel-path-using-lat-and-long-in-r
	https://cran.r-project.org/web/packages/od/vignettes/od.html
	https://jcheshire.com/visualisation/mapping-flows/


JEDI
	Race/ethnicity
	Income
	PLACES
		https://experience.arcgis.com/experience/22c7182a162d45788dd52a2362f8ed65/.

Climate susceptibility (work w Nancy)
	species list

Other groups
	TB giveaways
	Grow centers
		origin destination
	BTT
	Baltimore Count 
		Nathan Fran
		Cary

PRODUCTS:
	About page of the website
		click through
		let the public see when and where
			tangible and interactive.
		by Watershed
	JPEGs for PowerPoints
		simple communication tools
	Grant support?

Darin to-do:
	2008 - 2012 data
	2018 and 2019 need to double check
	email connection to Baltimore County
	September giveaway

# - Making the BWB Giveaway Location tribble
```{r}
# Making the tribble of giveaway_location
bwb_location_tribble <- 
  tribble(
  ~giveaway_location,                    ~entry_lat,                 ~entry_long,
  "Stillmeadow Community Fellowship",    "39.28149118084636",  "-76.6997041893354",
  "Herring Run Nursery",                 "39.372663174533386", "-76.578550239174",
  "Ridgely Manor Park",                  "39.39538407285143",  "-76.56664381155105",
  "Gwynns Falls Leakin Park",            "39.305631357367936", "-76.67893666401586", #Middle of the road
  "32nd Street Farmers Market",          "39.327535288081634", "-76.61061523990948",
  "JFX Farmers Market",                  "39.29268203155298",  "-76.60972412564519", 
  "REI Timonium",                        "39.43890264845818",  "-76.62880958625296",
  "West Towson ES",                      "39.404394375314446", "-76.63415717606557", #Assuming the elementary school
  "Cromwell Valley Harvest Festival",    "39.413977875188515", "-76.54667168973407", #Assuming Cromwell Valley Park
  "Cromwell Valley Park",                "39.413977875188515", "-76.54667168973407",
  "John Ruhrah ES",                      "39.28432439568278",  "-76.55246223392345",
  "Winand ES",                           "39.373018849783186", "-76.76232960664596",
  "St Matthews Catholic Church",         "39.35582240264951",  "-76.58866546616363",
  "Cherry Hill Urban Garden",            "39.24991878412569",  "-76.6270369680151",
  "Langston Hughes Community Center",    "39.34257749269637",  "-76.68024157650481",
  "Darley Park Gateway",                 "39.31530315544997",  "-76.59325254326163", 
  "Anneslie",                            "39.37594316032152",  "-76.60440999973999",
  "Ridgeleigh",                          "39.39532552607871",  "-76.55700617739024", #Assuming Ridgeleigh Park
  "Rodgers Forge",                       "39.377385831798314", "-76.62046978150337", #Assuming the Stoneleigh apartment
  "Stoneleigh",                          "39.38293280601465",  "-76.60227172784485", #Assuming a local park
  "Washington Hill Fall Community Day",  "39.29153646657451",  "-76.59385521007198", #Assuming middle of street
  "Chestnut Hill",                       "39.334010001213116", "-76.60617940430386"  #Assuming Chestnut Hill Park
  )

# Making the sf object
bwb_giveaway_location_sf <-
  bwb_giveaway_location |>
    left_join(bwb_location_tribble, by = "giveaway_location")
```

- You need to make an API token before you can use this package

- Here is the webpage to make the token: https://account.mapbox.com/auth/signup/?route-to=%22https%3A%2F%2Faccount.mapbox.com%2Faccess-tokens%2F%22

- Apparently, it appears to be pay-to-use (or at least depending on how many people access the map)

```{r}
# Setting the mapbox token
set_token("pk.eyJ1IjoiZWR1YXJkb3NtYXJpbiIsImEiOiJjbHd2OXFsam0wbnk3MmtxOHlqYW1xbXFqIn0.WyYbUxQ1_9SwZvGBEqUehA")

# Making the origin destination

bwb_giveaway_location_sf$entry_lat <-
  as.numeric(as.character(bwb_giveaway_location_sf$entry_lat))

bwb_giveaway_location_sf$entry_long <-
  as.numeric(as.character(bwb_giveaway_location_sf$entry_long))

# Making the ending destination

## First have to find retrieve again the lat and long
coords_bwb_total_giveaway <- 
  st_coordinates(bwb_total_giveaway)

coords_bwb_data_frame <-   
  as.data.frame(coords_bwb_total_giveaway) |>
  rename(ending_lat = "X", ending_long = "Y")

bwb_total_giveaway_lat_long <-
  cbind(st_drop_geometry(bwb_total_giveaway), ... = coords_bwb_data_frame) |>
  rename("ending_long" = "....ending_lat", "ending_lat" = "....ending_long")

## Re-doing what we did earlier

bwb_total_giveaway_lat_long$ending_lat <-
  as.numeric(as.character(bwb_total_giveaway_lat_long$ending_lat))

bwb_total_giveaway_lat_long$ending_long <-
  as.numeric(as.character(bwb_total_giveaway_lat_long$ending_long))

## Left joining to add the entry_lat and entry_long for the same dataframe
bwb_total_giveaway_destination <-
left_join(bwb_total_giveaway_lat_long, bwb_giveaway_location_sf, by = "giveaway_location") |>
  dplyr::select(-`valid_percent`,-`Number of Trees`,-`percent`) |>
  filter(!is.na(giveaway_location))

bwb_total_giveaway_destination |>
  write_csv("output_data/bwb_total_giveaway_destination")
  
  
## Using mapdeck
mapdeck(
  style = mapdeck_style('dark')
  , location = c(104, 1)
  , zoom = 8
  , pitch = 45
) |>
  add_arc(
    data = bwb_total_giveaway_destination
    , origin = c("entry_long", "entry_lat")
    , destination = c("ending_long", "ending_lat")
    , layer_id = 'arcs'
    , stroke_from_opacity = 100
    , stroke_to_opacity = 100
    , stroke_width = 3
    , stroke_from = "#ccffff"
    , stroke_to = "#ccffff"
  )

```

# Another cool package that seems to do the same but in a matrix:
https://personal.tcu.edu/kylewalker/interactive-flow-visualization-in-r.html

```{r}
  